# Cosmetic Test Repair Workflow

The cosmetic repair workflow provides a **manual**, dispatch-only escape hatch
for acknowledged formatting and tolerance drift. It never runs automatically on
push or pull requests. Instead, a repository maintainer can trigger the
workflow when a cosmetic failure blocks a merge.

## When to use the workflow

* Pytest failures marked with `@pytest.mark.cosmetic` and carrying a
  `COSMETIC_*` payload in the assertion message.
* Known guard rails exist in the affected files (for example, lines annotated
  with `# cosmetic-repair: float EXPECTED_ALPHA`).
* The failure can be resolved mechanically by updating stored baselines or
  numeric tolerances.

Do **not** run the workflow for runtime or behavioural regressions—open a
standard fix PR instead.

## Workflow outline

1. Launch the workflow from the **Actions** tab by selecting
   _Cosmetic repair_ → **Run workflow**. Optional inputs allow you to run in
   dry-run mode or append a suffix to the generated branch name.
2. The job executes `pytest -q --junitxml=.pytest-cosmetic-report.xml`.
3. `scripts/ci_cosmetic_repair.py` parses the report, looks for failure messages
   containing `COSMETIC_TOLERANCE` or `COSMETIC_SNAPSHOT`, and validates that
   each target line opts-in via a `# cosmetic-repair:` guard.
4. Eligible files are patched deterministically. Each modified line retains the
   guard comment so reviewers know the change was generated by automation.
5. When changes exist, the script commits them on a branch named
   `autofix/cosmetic-repair-<timestamp>` (or with the provided suffix), pushes
the branch, and opens a pull request labelled `testing` and `autofix:applied`.
6. The workflow writes `.cosmetic-repair-summary.json`, which feeds the job
   summary with the execution status, changed files, and PR link (when one is
   created).

If re-run after the drift is already repaired, the script exits cleanly without
creating a new branch or PR.

## Local execution

Developers can run the same logic locally:

```bash
python scripts/ci_cosmetic_repair.py --apply --skip-pr
```

* Use `--dry-run` to inspect the planned fixes without modifying files.
* Pass `--report <path>` to analyse an existing JUnit XML report instead of
  running pytest.
* `--branch-suffix` lets you append a human-friendly token to the generated
  branch name when creating a PR.

Ensure the working tree is clean before running in `--apply` mode. The script
will refuse to operate on files outside the repository root and only touches
lines that explicitly declare the cosmetic guard comment.
