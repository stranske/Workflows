name: Agents 70 Main (Reusable)

on:
  workflow_call:
    inputs:
      init_success:
        description: 'Whether init phase succeeded'
        required: true
        type: string
      enable_readiness:
        type: string
        required: false
      readiness_agents:
        type: string
        required: false
      readiness_custom_logins:
        type: string
        required: false
      require_all:
        type: string
        required: false
      enable_preflight:
        type: string
        required: false
      codex_user:
        type: string
        required: false
      codex_command_phrase:
        type: string
        required: false
      enable_diagnostic:
        type: string
        required: false
      diagnostic_attempt_branch:
        type: string
        required: false
      diagnostic_dry_run:
        type: string
        required: false
      enable_verify_issue:
        type: string
        required: false
      verify_issue_number:
        type: string
        required: false
      enable_watchdog:
        type: string
        required: false
      enable_keepalive:
        type: string
        required: false
      keepalive_pause_label:
        type: string
        required: false
      keepalive_max_retries:
        type: string
        required: false
      enable_bootstrap:
        type: string
        required: false
      bootstrap_issues_label:
        type: string
        required: false
      draft_pr:
        type: string
        required: false
      verify_issue_valid_assignees:
        type: string
        required: false
      dry_run:
        type: string
        required: false
      options_json:
        type: string
        required: false
      dispatcher_force_issue:
        type: string
        required: false
      worker_max_parallel:
        type: string
        required: false
      conveyor_max_merges:
        type: string
        required: false
      keepalive_trace:
        type: string
        required: false
      keepalive_round:
        type: string
        required: false
      keepalive_pr:
        type: string
        required: false
      token_source:
        type: string
        required: false
    secrets:
      ACTIONS_BOT_PAT:
        required: false
      SERVICE_BOT_PAT:
        required: false
      OWNER_PR_PAT:
        required: false
      WORKFLOWS_APP_ID:
        required: false
      WORKFLOWS_APP_PRIVATE_KEY:
        required: false

jobs:
  keepalive-guard:
    name: Evaluate keepalive gate
    if: inputs.init_success == 'success'
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.guard.outputs.proceed || 'true' }}
      reason: ${{ steps.guard.outputs.reason || '' }}
      agent_alias: ${{ steps.guard.outputs.agent_alias || '' }}
      run_cap: ${{ steps.guard.outputs.run_cap || '' }}
      active_runs: ${{ steps.guard.outputs.active_runs || '' }}
      active_runs_inflight: ${{ steps.guard.outputs.active_runs_inflight || '' }}
      active_runs_recent: ${{ steps.guard.outputs.active_runs_recent || '' }}
      active_runs_recent_window: ${{ steps.guard.outputs.active_runs_recent_window || '' }}
      has_sync_label: ${{ steps.guard.outputs.has_sync_label || 'false' }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Checkout guard helpers
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Evaluate keepalive prerequisites
        id: guard
        uses: actions/github-script@v8
        env:
          KEEPALIVE_ENABLED: ${{ inputs.enable_keepalive }}
          KEEPALIVE_TRACE: ${{ inputs.keepalive_trace }}
          KEEPALIVE_ROUND: ${{ inputs.keepalive_round }}
          KEEPALIVE_PR: ${{ inputs.keepalive_pr }}
          KEEPALIVE_MAX_RETRIES: ${{ inputs.keepalive_max_retries || '5' }}
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            // Do not remove checkout; local helper is required.
            const { runKeepaliveGate } = require('./.github/scripts/keepalive_orchestrator_gate_runner.js');
            await runKeepaliveGate({ core, github, context, env: process.env });

      - name: Debug keepalive gate outputs
        if: always()
        run: |
          echo "::notice::keepalive_gate_proceed=${{ steps.guard.outputs.proceed }}"
          echo "::notice::keepalive_gate_reason=${{ steps.guard.outputs.reason }}"
          echo "::notice::resolve_enable_keepalive=${{ inputs.enable_keepalive }}"
          echo "::notice::keepalive_run_cap=${{ steps.guard.outputs.run_cap }}"
          echo "::notice::keepalive_active_runs=${{ steps.guard.outputs.active_runs }}"
          echo "::notice::keepalive_active_runs_inflight=${{ steps.guard.outputs.active_runs_inflight }}"
          echo "::notice::keepalive_active_runs_recent=${{ steps.guard.outputs.active_runs_recent }}"
          echo "::notice::keepalive_active_runs_recent_window=${{ steps.guard.outputs.active_runs_recent_window }}"

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr="${PR_NUMBER:-}"
          if [[ -n "${pr}" ]]; then
            pr="#${pr}"
          else
            pr="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE:-0}"
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
            "${ok}" "${reason}" "${pr}" "${agent}" "${cap}" "${active}" "${head}" >>"$GITHUB_STEP_SUMMARY"
        env:
          OK: ${{ steps.guard.outputs.proceed || 'false' }}
          REASON: ${{ steps.guard.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ inputs.keepalive_pr || '' }}
          AGENT_ALIAS: ${{ steps.guard.outputs.agent_alias || '' }}
          CAP: ${{ steps.guard.outputs.cap || steps.guard.outputs.run_cap || '2' }}
          ACTIVE: ${{ steps.guard.outputs.active || steps.guard.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.guard.outputs.head_sha || '' }}


  keepalive-cap:
    name: Enforce keepalive run cap
    needs:
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false'
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.cap.outputs.ok || 'false' }}
      reason: ${{ steps.cap.outputs.reason || '' }}
      active: ${{ steps.cap.outputs.active || '' }}
      cap: ${{ steps.cap.outputs.cap || '' }}
    steps:
      - name: Checkout run cap helpers
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Evaluate orchestrator run cap
        id: cap
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ inputs.keepalive_pr || '' }}
          ENABLE_KEEPALIVE: ${{ inputs.enable_keepalive || 'false' }}
          FALLBACK_WORKER_MAX: ${{ inputs.worker_max_parallel || '1' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateRunCapForPr } = require('./.github/scripts/keepalive_gate.js');

            const normalise = (value) => String(value || '').trim();
            const enableKeepalive = normalise(process.env.ENABLE_KEEPALIVE).toLowerCase() === 'true';
            const fallbackMaxRaw = normalise(process.env.FALLBACK_WORKER_MAX || '1');
            const fallbackMax = (() => {
              const parsed = Number.parseInt(fallbackMaxRaw, 10);
              if (!Number.isFinite(parsed) || parsed <= 0) {
                return 1;
              }
              return Math.max(1, Math.min(parsed, 5));
            })();

            if (!enableKeepalive) {
              core.setOutput('ok', 'true');
              core.setOutput('reason', 'keepalive-disabled');
              core.setOutput('cap', String(fallbackMax));
              core.setOutput('active', '0');
              return;
            }

            const prValue = Number.parseInt(normalise(process.env.PR_NUMBER), 10);

            if (!Number.isFinite(prValue) || prValue <= 0) {
              core.setOutput('ok', 'false');
              core.setOutput('reason', 'missing-pr-number');
              core.setOutput('cap', '');
              core.setOutput('active', '');
              return;
            }

            const { owner, repo } = context.repo;
            const currentRunId = context.runId;
            const result = await evaluateRunCapForPr({
              core,
              github,
              owner,
              repo,
              prNumber: prValue,
              includeWorker: false,
              currentRunId,
            });

            const bool = (value) => (value ? 'true' : 'false');
            let capValue = Number(result.runCap);
            if (!Number.isFinite(capValue) || capValue <= 0) {
              capValue = 2;
            } else {
              capValue = Math.max(1, Math.min(capValue, 5));
            }
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('cap', String(capValue));
            core.setOutput('active', String(result.activeRuns ?? ''));

      - name: Summarise run cap decision
        if: steps.cap.outputs.ok == 'false'
        run: |
          set -euo pipefail
          reason="${REASON:-run-cap-reached}"
          pr="${PR_NUMBER:-?}"
          cap="${CAP:-?}"
          active="${ACTIVE:-0}"
          printf 'CAP: ok=false reason=%s pr=#%s cap=%s active=%s\n' \
            "${reason}" "${pr}" "${cap}" "${active}" >>"$GITHUB_STEP_SUMMARY"
        env:
          REASON: ${{ steps.cap.outputs.reason || 'run-cap-reached' }}
          PR_NUMBER: ${{ inputs.keepalive_pr || '' }}
          CAP: ${{ steps.cap.outputs.cap || '' }}
          ACTIVE: ${{ steps.cap.outputs.active || '' }}


  resolve-orchestrator-context:
    name: Resolve orchestrator context
    needs:
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number || '' }}
      agent_alias: ${{ steps.resolve.outputs.agent_alias || '' }}
    steps:
      - name: Resolve PR number and agent alias
        id: resolve
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ev = context.payload || {};

            const parseMaybeJson = (value) => {
              if (!value) {
                return null;
              }
              if (typeof value === 'object') {
                return value;
              }
              if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                  return null;
                }
                try {
                  return JSON.parse(trimmed);
                } catch (error) {
                  core.warning(`resolve-context: failed to parse JSON payload: ${error.message || error}`);
                  return null;
                }
              }
              return null;
            };

            let prNumber =
              ev.pull_request?.number ??
              ev.issue?.number ??
              ev.workflow_run?.pull_requests?.[0]?.number ??
              ev.inputs?.pr_number ??
              ev.client_payload?.pr ??
              ev.client_payload?.pr_number ??
              ev.client_payload?.issue ??
              null;

            const normaliseString = (value) => {
              if (value === null || value === undefined) {
                return '';
              }
              return String(value).trim();
            };

            const inputOptions = parseMaybeJson(ev.inputs?.options_json);
            const payloadOptions = parseMaybeJson(ev.client_payload?.options_json || ev.client_payload?.options);

            const fromPayload =
              normaliseString(ev.client_payload?.agent) ||
              normaliseString(ev.client_payload?.agent_alias) ||
              (payloadOptions && (normaliseString(payloadOptions.agent) || normaliseString(payloadOptions.agent_alias))) ||
              (inputOptions && (normaliseString(inputOptions.agent) || normaliseString(inputOptions.agent_alias))) ||
              null;

            const agentFromLabels = async (value) => {
              if (!value) {
                return null;
              }
              const numeric = Number.parseInt(String(value), 10);
              if (!Number.isFinite(numeric) || numeric <= 0) {
                return null;
              }
              try {
                const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: numeric,
                  per_page: 100,
                });
                const agentLabel = Array.isArray(labels)
                  ? labels.find((entry) => {
                      const labelName = typeof entry === 'string' ? entry : entry?.name;
                      return typeof labelName === 'string' && /^agent:/i.test(labelName);
                    })
                  : null;
                if (!agentLabel) {
                  return null;
                }
                const value = typeof agentLabel === 'string' ? agentLabel : agentLabel?.name;
                if (typeof value !== 'string') {
                  return null;
                }
                const stripped = value.replace(/^agent:/i, '').trim();
                return stripped || null;
              } catch (error) {
                core.warning(`resolve-context: failed to fetch labels for #${numeric}: ${error.message || error}`);
                return null;
              }
            };

            let agentAlias = fromPayload;
            if (!agentAlias) {
              agentAlias = await agentFromLabels(prNumber);
            }
            agentAlias = normaliseString(agentAlias);
            if (!agentAlias) {
              agentAlias = 'codex';
            }

            const prNumberString = normaliseString(prNumber);
            const resolvedPrNumber = prNumberString || String(context.runId);

            core.setOutput('pr_number', resolvedPrNumber);
            core.setOutput('agent_alias', agentAlias);

            core.info(`Resolved orchestrator context: pr_number=${resolvedPrNumber}, agent_alias=${agentAlias}`);


  keepalive-prep:
    name: Prepare keepalive round
    needs:
      - keepalive-guard
      - keepalive-cap
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_keepalive == 'true' &&
      needs.keepalive-cap.outputs.ok == 'true'
    runs-on: ubuntu-latest
    outputs:
      round: ${{ steps.prepare.outputs.round || '' }}
      trace: ${{ steps.prepare.outputs.trace || '' }}
      actions_available: ${{ steps.prepare.outputs.actions_available || 'false' }}
      dispatch_mode: ${{ steps.prepare.outputs.dispatch_mode || '' }}
      scope_tasks_acceptance: ${{ steps.prepare.outputs.scope_tasks_acceptance || '' }}
      scope_block: ${{ steps.prepare.outputs.scope_block || '' }}
      pr_number: ${{ steps.prepare.outputs.pr_number || '' }}
      baseline_head: ${{ steps.snapshot.outputs.head || '' }}
      head_ref: ${{ steps.snapshot.outputs.head_ref || '' }}
      base_ref: ${{ steps.snapshot.outputs.base_ref || '' }}
      agent: ${{ steps.render_instruction_body.outputs.agent || steps.prepare.outputs.agent || '' }}
      body: ${{ steps.render_instruction_body.outputs.body || '' }}
      instruction_body: ${{ steps.extract_instruction_segment.outputs.instruction || '' }}
      instruction_bytes: ${{ steps.extract_instruction_segment.outputs.bytes || '0' }}
      previous_round: ${{ steps.prepare.outputs.previous_round || '' }}
      existing_instruction_comment_id: ${{ steps.prepare.outputs.existing_instruction_comment_id || '' }}
      existing_instruction_comment_url: ${{ steps.prepare.outputs.existing_instruction_comment_url || '' }}
      existing_instruction_round: ${{ steps.prepare.outputs.existing_instruction_round || '' }}
      existing_instruction_trace: ${{ steps.prepare.outputs.existing_instruction_trace || '' }}
      existing_instruction_author: ${{ steps.prepare.outputs.existing_instruction_author || '' }}
      existing_instruction_reaction: ${{ steps.prepare.outputs.existing_instruction_reaction || 'false' }}
      head_repo: ${{ steps.snapshot.outputs.head_repo || '' }}
    steps:
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
            scripts/keepalive_instruction_segment.js
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Prepare keepalive instruction
        id: prepare
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ inputs.keepalive_pr }}
          ROUND_HINT: ${{ inputs.keepalive_round }}
          OPTIONS_JSON: ${{ inputs.options_json }}
          ACTIONS_AVAILABLE: ${{ secrets.ACTIONS_BOT_PAT != '' }}
          SERVICE_AVAILABLE: ${{ secrets.SERVICE_BOT_PAT != '' }}
          AGENT_ALIAS: ${{ needs.keepalive-guard.outputs.agent_alias }}
        with:
          script: |
            const { makeTrace, renderInstruction } = require('./.github/scripts/keepalive_contract.js');

            const normalise = (value) => String(value || '').trim();
            const normaliseNewlines = (value) => normalise(value).replace(/\r\n/g, '\n');
            const prNumberRaw = normalise(process.env.PR_NUMBER);
            const prNumber = Number.parseInt(prNumberRaw, 10);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Keepalive instruction requires a valid pull request number.');
              return;
            }

            const agentAlias = normalise(process.env.AGENT_ALIAS) || 'codex';

            let instruction = '';
            const optionsSource = process.env.OPTIONS_JSON || '{}';
            try {
              const parsed = JSON.parse(optionsSource);
              instruction = parsed.keepalive_instruction || parsed.keepalive_instruction_template || '';
            } catch (error) {
              core.warning(`Unable to parse keepalive options (${error.message}).`);
            }

            if (!instruction) {
              core.setFailed('Keepalive instruction template missing.');
              return;
            }

            const roundHint = Number.parseInt(normalise(process.env.ROUND_HINT), 10);
            let round = Number.isFinite(roundHint) && roundHint > 0 ? roundHint : 0;

            const { owner, repo } = context.repo;
            const { extractIssueNumberFromPull } = require('./.github/scripts/agents_pr_meta_keepalive.js');

            const defaultSections = {
              scope: '_Keepalive checklist unavailable; will retry next round._',
              tasks: '- [ ] _Rehydrate keepalive checklist content_',
              acceptance: '- [ ] _Rehydrate keepalive checklist content_',
            };

            const formatBlock = ({ scope, tasks, acceptance }) => {
              const ensureChecklist = (value, fallback) => {
                const trimmed = String(value || '').trim();
                if (!trimmed) {
                  return fallback;
                }
                return trimmed
                  .split('\n')
                  .map((line) => {
                    const raw = String(line || '').trim();
                    if (!raw) {
                      return '- [ ]';
                    }
                    if (/^[-*]\s*\[[ xX]\]/.test(raw)) {
                      const mark = raw.match(/^[-*]\s*\[([ xX])\]/)[1];
                      const rest = raw.replace(/^[-*]\s*\[[ xX]\]\s*/, '');
                      const normalisedMark = mark.toLowerCase() === 'x' ? 'x' : ' ';
                      return `- [${normalisedMark}] ${rest.trim()}`;
                    }
                    if (/^[-*]\s+/.test(raw)) {
                      const rest = raw.replace(/^[-*]\s+/, '');
                      return `- [ ] ${rest.trim()}`;
                    }
                    return `- [ ] ${raw}`;
                  })
                  .join('\n');
              };

              const trimmed = (value, fallback) => {
                const text = String(value || '').trim();
                return text || fallback;
              };

              return [
                '#### Scope',
                trimmed(scope, defaultSections.scope),
                '',
                '#### Tasks',
                ensureChecklist(tasks, defaultSections.tasks),
                '',
                '#### Acceptance criteria',
                ensureChecklist(acceptance, defaultSections.acceptance),
              ]
                .map((block) => block.replace(/\s+$/, ''))
                .join('\n');
            };

            const defaultScopeBlock = formatBlock(defaultSections);

            const parseSections = (body) => {
              const content = normaliseNewlines(body);
              if (!content) {
                return null;
              }
              const section = (labels) => {
                const patterns = Array.isArray(labels) ? labels : [labels];
                for (const label of patterns) {
                  const pattern = new RegExp(`####\\s*${label}\\s*([\\s\\S]*?)(?=####\\s*|$)`, 'i');
                  const match = content.match(pattern);
                  if (match && match[1]) {
                    return match[1].trim();
                  }
                }
                return '';
              };

              const sections = {
                scope: section('Scope'),
                tasks: section(['Tasks', 'Task list']),
                acceptance: section(['Acceptance criteria', 'Acceptance Criteria', 'Success criteria', 'Definition of done']),
              };

              const values = Object.values(sections).filter((value) => String(value || '').trim());
              return values.length > 0 ? sections : null;
            };

            const extractKeepaliveChecklist = (body) => {
              const match = normaliseNewlines(body).match(/###\s*Keepalive checklist\s*([\s\S]*)/i);
              if (!match) {
                return '';
              }
              const remainder = match[1] || '';
              const next = remainder.search(/\n###\s+/);
              const segment = next >= 0 ? remainder.slice(0, next) : remainder;
              return segment.trim();
            };

            let scopeBlock = defaultScopeBlock;
            let scopeSource = 'placeholder';

            try {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const prBody = pr?.body || '';
              const keepaliveSection = extractKeepaliveChecklist(prBody);
              const fromKeepalive = parseSections(keepaliveSection);
              if (fromKeepalive) {
                scopeBlock = formatBlock(fromKeepalive);
                scopeSource = 'pr-keepalive';
              } else {
                const issueNumber = extractIssueNumberFromPull(pr);
                if (issueNumber) {
                  try {
                    const issueResponse = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                    const issueSections = parseSections(issueResponse.data?.body || '');
                    if (issueSections) {
                      scopeBlock = formatBlock(issueSections);
                      scopeSource = 'issue-body';
                    }
                  } catch (issueError) {
                    const message = issueError instanceof Error ? issueError.message : String(issueError);
                    core.warning(`Unable to read source issue #${issueNumber} for PR #${prNumber}: ${message}`);
                  }
                }

                if (scopeSource === 'placeholder') {
                  try {
                    const comments = await github.paginate(github.rest.issues.listComments, {
                      owner,
                      repo,
                      issue_number: prNumber,
                      per_page: 100,
                    });
                    const candidates = comments
                      .filter((comment) => /##\s*Automated Status Summary/i.test(comment?.body || ''))
                      .sort((a, b) => new Date(b.updated_at || b.created_at || 0) - new Date(a.updated_at || a.created_at || 0));
                    const latest = candidates[0];
                    const fromComment = latest ? parseSections(latest.body || '') : null;
                    if (fromComment) {
                      scopeBlock = formatBlock(fromComment);
                      scopeSource = 'auto-status-comment';
                    }
                  } catch (commentError) {
                    const message = commentError instanceof Error ? commentError.message : String(commentError);
                    core.warning(`Unable to inspect keepalive status comments: ${message}`);
                  }
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to extract scope/tasks/acceptance for PR #${prNumber}: ${message}`);
              scopeBlock = defaultScopeBlock;
            }

            core.info(`Keepalive scope block sourced from: ${scopeSource}`);
            core.setOutput('scope_block_source', scopeSource);

            core.exportVariable('SCOPE_TASKS_ACCEPTANCE', scopeBlock);
            core.setOutput('scope_block', scopeBlock);

            let highestRound = 0;
            const markerRegex = /<!--\s*codex-keepalive-marker\s*-->/;
            const roundRegex = /<!--\s*keepalive-round\s*:?#?\s*(\d+)\s*-->/;
            const traceRegex = /<!--\s*keepalive-trace\s*:?#?\s*([\s\S]*?)\s*-->/;
            let latestInstruction = null;

            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100,
              });
              for (const comment of comments) {
                const body = comment?.body || '';
                if (!markerRegex.test(body)) {
                  continue;
                }
                const roundMatch = body.match(roundRegex);
                const traceMatch = body.match(traceRegex);
                if (!roundMatch || !traceMatch) {
                  continue;
                }
                const parsedRound = Number.parseInt(roundMatch[1], 10);
                if (!Number.isFinite(parsedRound)) {
                  continue;
                }
                if (parsedRound > highestRound) {
                  highestRound = parsedRound;
                }

                const createdAtRaw = comment?.created_at || comment?.updated_at || '';
                const parsedCreatedAt = createdAtRaw ? Date.parse(createdAtRaw) : Number.NaN;
                const createdAt = Number.isFinite(parsedCreatedAt) ? parsedCreatedAt : 0;
                const updatedAtRaw = comment?.updated_at || comment?.created_at || '';
                const parsedUpdatedAt = updatedAtRaw ? Date.parse(updatedAtRaw) : Number.NaN;
                const updatedAt = Number.isFinite(parsedUpdatedAt) ? parsedUpdatedAt : createdAt;
                const candidate = {
                  round: parsedRound,
                  trace: traceMatch[1] ? traceMatch[1].trim() : '',
                  commentId: comment?.id ? String(comment.id) : '',
                  commentUrl: comment?.html_url || '',
                  author: comment?.user?.login || '',
                  createdAt,
                  updatedAt,
                  isEdited: Boolean(comment?.updated_at && comment?.created_at && comment.updated_at !== comment.created_at),
                };

                if (
                  !latestInstruction ||
                  candidate.round > latestInstruction.round ||
                  (candidate.round === latestInstruction.round && (
                    candidate.createdAt > latestInstruction.createdAt ||
                    (candidate.createdAt === latestInstruction.createdAt && candidate.commentId > latestInstruction.commentId)
                  ))
                ) {
                  latestInstruction = candidate;
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to scan existing keepalive comments: ${message}`);
            }

            core.setOutput('previous_round', highestRound ? String(highestRound) : '');

            let existingInstructionReaction = 'false';
            if (latestInstruction?.commentId) {
              const parsedCommentId = Number(latestInstruction.commentId);
              if (Number.isFinite(parsedCommentId)) {
                try {
                  const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                    owner,
                    repo,
                    comment_id: parsedCommentId,
                    per_page: 100,
                  });
                  existingInstructionReaction = reactions.some(
                    (reaction) => (reaction?.content || '').toLowerCase() === 'hooray'
                  )
                    ? 'true'
                    : 'false';
                } catch (reactionError) {
                  const message = reactionError instanceof Error ? reactionError.message : String(reactionError);
                  core.warning(
                    `Unable to retrieve reactions for keepalive instruction comment ${latestInstruction.commentId}: ${message}`
                  );
                }
              } else {
                core.warning(
                  `Skipping reaction inspection; keepalive instruction comment id "${latestInstruction.commentId}" is not numeric.`
                );
              }
            }

            if (latestInstruction) {
              // NOTE: This is a best-effort guard against duplicate postings. The orchestrator lacks
              // a shared lock, so concurrent runs could still interleave between this scan and the
              // eventual comment post. In practice the scheduled cadence keeps collisions low and
              // a matching hooray reaction will prevent ongoing duplication.
              core.setOutput('existing_instruction_comment_id', latestInstruction.commentId || '');
              core.setOutput('existing_instruction_comment_url', latestInstruction.commentUrl || '');
              core.setOutput('existing_instruction_round', String(latestInstruction.round ?? ''));
              core.setOutput('existing_instruction_trace', latestInstruction.trace || '');
              core.setOutput('existing_instruction_author', latestInstruction.author || '');
              core.setOutput('existing_instruction_reaction', existingInstructionReaction || 'false');
            } else {
              core.setOutput('existing_instruction_comment_id', '');
              core.setOutput('existing_instruction_comment_url', '');
              core.setOutput('existing_instruction_round', '');
              core.setOutput('existing_instruction_trace', '');
              core.setOutput('existing_instruction_author', '');
              core.setOutput('existing_instruction_reaction', 'false');
            }

            round = Math.max(round, highestRound) + 1;
            const trace = makeTrace();
            const combinedInstruction = [
              normaliseNewlines(instruction).trim(),
              scopeBlock,
            ]
              .filter(Boolean)
              .join('\n\n');

            const body = renderInstruction({ round, trace, body: combinedInstruction, agent: agentAlias });
            const tokenSource = normalise(process.env.AUTHOR_TOKEN_SOURCE).toUpperCase();
            const actionsAvailable = tokenSource === 'ACTIONS_BOT_PAT';
            const serviceAvailable = tokenSource === 'SERVICE_BOT_PAT';
            const dispatchMode = actionsAvailable
              ? 'actions'
              : serviceAvailable
                ? 'service'
                : 'none';
            const author = normalise(process.env.AUTHOR_LOGIN) || (actionsAvailable ? 'stranske' : 'stranske-automation-bot');

            core.setOutput('round', String(round));
            core.setOutput('trace', trace);
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('actions_available', actionsAvailable ? 'true' : 'false');
            core.setOutput('dispatch_mode', dispatchMode);
            core.setOutput('agent', agentAlias);
            core.setOutput('body', body);
            core.setOutput('scope_tasks_acceptance', instruction);
      - name: Capture keepalive head snapshot
        id: snapshot
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
        with:
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('head', '');
              core.setOutput('head_repo', '');
              core.setOutput('head_ref', '');
              core.setOutput('base_ref', '');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              core.setOutput('head', data?.head?.sha || '');
              core.setOutput('head_repo', data?.head?.repo?.full_name || '');
              core.setOutput('head_ref', data?.head?.ref || '');
              core.setOutput('base_ref', data?.base?.ref || '');
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to capture PR #${prNumber} head snapshot: ${message}`);
              core.setOutput('head', '');
              core.setOutput('head_repo', '');
              core.setOutput('head_ref', '');
              core.setOutput('base_ref', '');
            }

      - name: Persist keepalive head snapshot
        if: steps.snapshot.outputs.head != ''
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
          TRACE: ${{ steps.prepare.outputs.trace }}
          ROUND: ${{ steps.prepare.outputs.round }}
          HEAD_SHA: ${{ steps.snapshot.outputs.head }}
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            const trace = normalise(process.env.TRACE);
            const round = normalise(process.env.ROUND);
            const headSha = normalise(process.env.HEAD_SHA);
            if (!Number.isFinite(prNumber) || prNumber <= 0 || !trace || !headSha) {
              core.info('Keepalive state persistence skipped due to missing data.');
              return;
            }

            const { saveKeepaliveState } = require('./.github/scripts/keepalive_state.js');
            await saveKeepaliveState({
              github,
              context,
              prNumber,
              trace,
              round,
              updates: {
                head_sha: headSha,
                head_recorded_at: new Date().toISOString(),
              },
            });

      - name: Render keepalive instruction body
        id: render_instruction_body
        uses: actions/github-script@v8
        env:
          ROUND_DISPLAY: ${{ steps.prepare.outputs.round || '(unknown)' }}
          TRACE_DISPLAY: ${{ steps.prepare.outputs.trace || '(missing)' }}
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
          ROUND_VALUE: ${{ steps.prepare.outputs.round }}
          TRACE_VALUE: ${{ steps.prepare.outputs.trace }}
          COMMENT_BODY: ${{ steps.prepare.outputs.body }}
          SCOPE_TASKS_ACCEPTANCE: ${{ steps.prepare.outputs.scope_tasks_acceptance }}
          SCOPE_BLOCK: ${{ steps.prepare.outputs.scope_block }}
          AUTHOR_DISPLAY: stranske-automation-bot
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number(process.env.PR_NUMBER || 0);

            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Unable to determine pull request number for keepalive instruction.');
              return;
            }

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const agentLabels = Array.isArray(labels)
              ? labels.filter((entry) => typeof entry?.name === 'string' && /^agent:/i.test(entry.name))
              : [];
            const agentAlias = agentLabels.length
              ? agentLabels[0].name.replace(/^agent:/i, '').trim() || 'codex'
              : 'codex';

            const staBlock = (process.env.SCOPE_BLOCK || '').trim()
              || (process.env.SCOPE_TASKS_ACCEPTANCE || '').trim()
              || '*(scope/tasks/acceptance inserted here by orchestrator)*';

            const round = process.env.ROUND_VALUE || process.env.ROUND_DISPLAY || '(unknown)';
            const trace = process.env.TRACE_VALUE || process.env.TRACE_DISPLAY || '(missing)';
            const providedBody = (process.env.COMMENT_BODY || '').trim();

            // Load instruction directive from template file
            const { getKeepaliveInstructionWithMention } = require('./.github/scripts/keepalive_instruction_template.js');
            const instructionDirective = getKeepaliveInstructionWithMention(agentAlias);

            let body = providedBody;
            if (!body) {
              body = [
                `<!-- keepalive-round: ${round} -->`,
                '<!-- codex-keepalive-marker -->',
                `<!-- keepalive-trace: ${trace} -->`,
                instructionDirective,
                '',
                staBlock,
              ].filter(Boolean).join('\n');
            }

            const preview = body.split('\n').slice(0, 6).join('\n') || '(empty)';
            await core.summary
              .addHeading('Keepalive instruction preview', 3)
              .addRaw(`Round: ${round}  Trace: ${trace}  Agent: @${agentAlias}`)
              .addEOL()
              .addCodeBlock(preview, 'markdown')
              .write();

            core.setOutput('agent', agentAlias);
            core.setOutput('body', body);
            core.setOutput('pr_number', String(prNumber));

      - name: Extract instruction payload
        id: extract_instruction_segment
        uses: actions/github-script@v8
        env:
          COMMENT_BODY: ${{ steps.render_instruction_body.outputs.body }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const {
              extractInstructionSegment,
              computeInstructionByteLength,
            } = require('./scripts/keepalive_instruction_segment.js');

            const body = process.env.COMMENT_BODY || '';
            const instruction = extractInstructionSegment(body);
            if (!instruction) {
              core.setFailed('Keepalive instruction payload is empty after trimming.');
              return;
            }

            core.setOutput('instruction', instruction);
            core.setOutput('bytes', String(computeInstructionByteLength(instruction)));

  orchestrate:
    name: Dispatch Agents Toolkit
    needs:
      - keepalive-guard
      - resolve-orchestrator-context
    if: needs.keepalive-guard.outputs.proceed != 'false'
    concurrency:
      group: ${{ format('keepalive-orchestrator-pr-{0}-agent-{1}-run-{2}', needs.resolve-orchestrator-context.outputs.pr_number || github.run_id, needs.resolve-orchestrator-context.outputs.agent_alias || 'codex', github.run_id) }}
      cancel-in-progress: false
    permissions:
      actions: write
      contents: write
      pull-requests: write
      issues: write
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ inputs.enable_readiness }}
      readiness_agents: ${{ inputs.readiness_agents }}
      readiness_custom_logins: ${{ inputs.readiness_custom_logins }}
      require_all: ${{ inputs.require_all }}
      enable_preflight: ${{ inputs.enable_preflight }}
      codex_user: ${{ inputs.codex_user }}
      codex_command_phrase: ${{ inputs.codex_command_phrase }}
      enable_diagnostic: ${{ inputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ inputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ inputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ inputs.enable_verify_issue }}
      verify_issue_number: ${{ inputs.verify_issue_number }}
      enable_watchdog: ${{ inputs.enable_watchdog }}
      enable_keepalive: ${{ inputs.enable_keepalive }}
      enable_bootstrap: ${{ inputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ inputs.bootstrap_issues_label }}
      draft_pr: ${{ inputs.draft_pr }}
      verify_issue_valid_assignees: ${{ inputs.verify_issue_valid_assignees }}
      dry_run: ${{ inputs.dry_run }}
      options_json: ${{ inputs.options_json }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  verify-assignment:
    name: Verify Assignment
    needs:
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_verify_issue == 'true' &&
      inputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ inputs.verify_issue_number }}
      valid_assignees: ${{ inputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - keepalive-guard
      - verify-assignment
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_verify_issue == 'true' &&
      inputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ inputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<-'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi

  belt-dispatch:
    name: Codex Belt Dispatcher
    needs:
      - keepalive-guard
    uses: ./.github/workflows/agents-71-codex-belt-dispatcher.yml
    with:
      force_issue: ${{ inputs.dispatcher_force_issue }}
      dry_run: ${{ inputs.dry_run == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-check-existing-pr:
    name: Guard existing Codex PRs
    needs:
      - belt-dispatch
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.belt-dispatch.outputs.issue != '' &&
      needs.belt-dispatch.outputs.branch != ''
    runs-on: ubuntu-latest
    outputs:
      pr_exists: ${{ steps.lookup.outputs.pr_exists || 'false' }}
      pr_number: ${{ steps.lookup.outputs.pr_number || '' }}
      pr_url: ${{ steps.lookup.outputs.pr_url || '' }}
    steps:
      - name: Detect existing PR for issue branch
        id: lookup
        uses: actions/github-script@v8
        env:
          KEEPALIVE_ENABLED: ${{ inputs.enable_keepalive }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = '${{ needs.belt-dispatch.outputs.branch }}';
            const summary = core.summary;
            const keepaliveEnabled = (process.env.KEEPALIVE_ENABLED || '').trim().toLowerCase() === 'true';

            summary.addHeading('Codex belt PR guard');

            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`,
              per_page: 1,
            });

            const existing = Array.isArray(pulls) && pulls.length > 0 ? pulls[0] : null;

            if (!existing) {
              summary.addRaw(`No open PR detected for branch \`${branch}\`.`).write();
              core.setOutput('pr_exists', 'false');
              core.setOutput('pr_number', '');
              core.setOutput('pr_url', '');
              return;
            }

            const prNumber = existing.number ? String(existing.number) : '';
            const prUrl = existing.html_url || (prNumber ? `https://github.com/${owner}/${repo}/pull/${prNumber}` : '');

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'rocket',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add ðŸŽ¯ reaction to keepalive comment ${commentId}: ${message}`);
            }

            core.info(keepaliveEnabled
              ? 'PR already exists; keepalive override allows worker to continue.'
              : 'PR already exists.');
            core.setOutput('pr_exists', 'true');
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_url', prUrl);

  belt-worker:
    name: Codex Belt Worker
    needs:
      - belt-dispatch
      - keepalive-guard
      - keepalive-cap
      - belt-check-existing-pr
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.keepalive-cap.outputs.ok == 'true' &&
      needs.keepalive-cap.outputs.cap != '0' &&
      needs.belt-dispatch.outputs.issue != ''
      && (
        needs.belt-check-existing-pr.outputs.pr_exists != 'true' ||
        inputs.enable_keepalive == 'true'
      )
    uses: ./.github/workflows/agents-72-codex-belt-worker.yml
    with:
      issue: ${{ needs.belt-dispatch.outputs.issue }}
      branch: ${{ needs.belt-dispatch.outputs.branch }}
      base: ${{ needs.belt-dispatch.outputs.base }}
      source: ${{ needs.belt-dispatch.outputs.reason }}
      dry_run: ${{ inputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true' }}
      max_parallel: ${{ fromJson(needs.keepalive-cap.outputs.cap || '1') }}
      keepalive: ${{ inputs.enable_keepalive == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  dry-run-branch-sync:
    name: Validate branch sync (dry-run)
    needs:
      - keepalive-guard
      - keepalive-prep
      - belt-dispatch
      - belt-worker
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_keepalive == 'true' &&
      (inputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true') &&
      needs.keepalive-prep.outputs.trace != '' &&
      needs.keepalive-prep.outputs.pr_number != '' &&
      needs.keepalive-prep.outputs.base_ref != '' &&
      needs.keepalive-prep.outputs.head_ref != '' &&
      needs.keepalive-prep.outputs.baseline_head != ''
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
      pull-requests: read
    outputs:
      run_url: ${{ steps.await.outputs.run_url || '' }}
      run_conclusion: ${{ steps.await.outputs.conclusion || '' }}
      run_id: ${{ steps.await.outputs.run_id || '' }}
      head_updated: ${{ steps.head_check.outputs.updated || 'false' }}
      new_head: ${{ steps.head_check.outputs.new_head || '' }}
      pr_url: ${{ steps.head_check.outputs.pr_url || '' }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Ensure branch-sync token available
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token }}
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -n "${APP_TOKEN}" ]; then
            exit 0
          fi
          if [ -z "${ACTIONS_TOKEN}" ]; then
            echo "::error::Branch-sync validation requires App token, ACTIONS_BOT_PAT, or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch keepalive branch sync
        id: dispatch
        uses: actions/github-script@v8
        env:
          WORKFLOW_ID: agents-keepalive-branch-sync.yml
          TARGET_REF: ${{ github.event.repository.default_branch }}
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          BASE_REF: ${{ needs.keepalive-prep.outputs.base_ref }}
          HEAD_REF: ${{ needs.keepalive-prep.outputs.head_ref }}
          HEAD_SHA: ${{ needs.keepalive-prep.outputs.baseline_head }}
          HEAD_REPO: ${{ needs.keepalive-prep.outputs.head_repo }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          AGENT: ${{ needs.keepalive-prep.outputs.agent }}
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const workflowId = process.env.WORKFLOW_ID || 'agents-keepalive-branch-sync.yml';
            let ref = (process.env.TARGET_REF || '').trim();
            if (!ref) {
              ref = context.payload?.repository?.default_branch || 'main';
            }
            ref = ref.replace(/^refs\/heads\//, '');

            const requiredKeys = ['PR_NUMBER', 'TRACE', 'BASE_REF', 'HEAD_REF', 'HEAD_SHA'];
            const missing = requiredKeys.filter((key) => !(process.env[key] || '').trim());
            if (missing.length) {
              core.setFailed(`Branch-sync dispatch missing inputs: ${missing.join(', ')}`);
              return;
            }

            const inputs = {
              pr_number: String(process.env.PR_NUMBER || ''),
              trace: String(process.env.TRACE || ''),
              base_ref: String(process.env.BASE_REF || ''),
              head_ref: String(process.env.HEAD_REF || ''),
              head_sha: String(process.env.HEAD_SHA || ''),
              head_repository: String(process.env.HEAD_REPO || ''),
              head_is_fork: '',
              agent: String(process.env.AGENT || ''),
              round: String(process.env.ROUND || ''),
            };

            const baseRepo = `${context.repo.owner}/${context.repo.repo}`.toLowerCase();
            const headRepo = (process.env.HEAD_REPO || '').toLowerCase();
            if (headRepo) {
              inputs.head_is_fork = headRepo !== baseRepo ? 'true' : 'false';
            }

            while (Date.now() < deadline) {
              const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                owner,
                repo,
                comment_id: commentId,
                per_page: 100,
              });
              if (reactions.some((reaction) => (reaction?.content || '').toLowerCase() === 'rocket')) {
                acknowledged = true;
                ackSource = 'reaction';
                break;
              }

              if (Date.now() - lastRunCheck >= runPollInterval) {
                lastRunCheck = Date.now();
                const runAck = await checkWorkflowRuns();
                if (runAck) {
                  acknowledged = true;
                  ackSource = 'pr-meta';
                  break;
                }
              }

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: workflowId,
              ref,
              inputs,
            });

            const now = new Date().toISOString();
            core.setOutput('ref', ref);
            core.setOutput('dispatched_at', now);
            core.setOutput('idempotency_key', inputs.idempotency_key);

      - name: Await branch-sync completion
        id: await
        uses: actions/github-script@v8
        env:
          WORKFLOW_ID: agents-keepalive-branch-sync.yml
          REF: ${{ steps.dispatch.outputs.ref }}
          DISPATCHED_AT: ${{ steps.dispatch.outputs.dispatched_at }}
          TIMEOUT_SECONDS: 600
          POLL_SECONDS: 15
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const workflowId = process.env.WORKFLOW_ID || 'agents-keepalive-branch-sync.yml';
            let ref = (process.env.REF || '').trim();
            if (!ref) {
              ref = context.payload?.repository?.default_branch || 'main';
            }
            const dispatchedAt = Date.parse(process.env.DISPATCHED_AT || new Date().toISOString());
            const timeoutMs = (Number(process.env.TIMEOUT_SECONDS) || 600) * 1000;
            const pollMs = (Number(process.env.POLL_SECONDS) || 15) * 1000;
            const deadline = Date.now() + timeoutMs;

            let runId = 0;
            let run = null;

            while (Date.now() < deadline) {
              if (!runId) {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflowId,
                  event: 'workflow_dispatch',
                  per_page: 20,
                });

                const candidates = Array.isArray(data.workflow_runs) ? data.workflow_runs : [];
                const candidate = candidates.find((entry) => {
                  const created = Date.parse(entry.created_at || 0);
                  if (!Number.isFinite(created) || created + 1000 < dispatchedAt - 2000) {
                    return false;
                  }
                  const headBranch = (entry.head_branch || '').trim();
                  if (headBranch && headBranch !== ref) {
                    return false;
                  }
                  return true;
                });

                if (candidate) {
                  runId = candidate.id;
                  run = candidate;
                }
              } else {
                const { data } = await github.rest.actions.getWorkflowRun({
                  owner,
                  repo,
                  run_id: runId,
                });
                run = data;
                if (run.status === 'completed') {
                  break;
                }
              }

              if (run && run.status === 'completed') {
                break;
              }

              await new Promise((resolve) => setTimeout(resolve, pollMs));
            }

            if (!run) {
              core.setFailed('Unable to locate branch-sync workflow run.');
              return;
            }

            if (run.status !== 'completed') {
              core.setFailed(`Branch-sync workflow did not complete before timeout (status=${run.status}).`);
              return;
            }

            core.setOutput('run_id', String(run.id || ''));
            core.setOutput('run_url', run.html_url || '');
            core.setOutput('conclusion', run.conclusion || '');
            core.setOutput('status', run.status || '');

            if ((run.conclusion || '').toLowerCase() !== 'success') {
              core.setFailed(`Branch-sync workflow concluded with ${run.conclusion || 'unknown'}.`);
            }

      - name: Check staging PR head
        id: head_check
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head }}
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            const baseline = normalise(process.env.BASELINE_HEAD);

            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('updated', 'false');
              core.setOutput('new_head', '');
              core.setOutput('pr_url', '');
              return;
            }

            const { owner, repo } = context.repo;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const newHead = normalise(pr?.head?.sha);
            core.setOutput('new_head', newHead);
            core.setOutput('updated', newHead && baseline && newHead !== baseline ? 'true' : 'false');
            core.setOutput('pr_url', pr?.html_url || `https://github.com/${owner}/${repo}/pull/${prNumber}`);

      - name: Summarise branch-sync validation
        env:
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          RUN_URL: ${{ steps.await.outputs.run_url }}
          CONCLUSION: ${{ steps.await.outputs.conclusion }}
          PR_URL: ${{ steps.head_check.outputs.pr_url }}
          UPDATED: ${{ steps.head_check.outputs.updated }}
          NEW_HEAD: ${{ steps.head_check.outputs.new_head }}
        run: |
          head_change='unchanged'
          if [ "${UPDATED}" = 'true' ] && [ -n "${NEW_HEAD}" ]; then
            head_change="advanced to ${NEW_HEAD:0:12}"
          fi

          sync_link='(not available)'
          if [ -n "${RUN_URL}" ]; then
            sync_link="[run](${RUN_URL})"
          fi

          pr_link='(n/a)'
          if [ -n "${PR_URL}" ]; then
            pr_link="[link](${PR_URL})"
          fi

          cat <<EOF >>"$GITHUB_STEP_SUMMARY"
          ## Branch-sync validation
          | Round | Trace | Result | Sync run | PR | Head change |
          |---|---|---|---|---|---|
          | ${ROUND:-?} | \`${TRACE:-n/a}\` | ${CONCLUSION:-unknown} | ${sync_link} | ${pr_link} | ${head_change} |
          EOF

  keepalive-post-work:
    name: Keepalive post-work sync
    needs:
      - keepalive-guard
      - keepalive-prep
      - belt-dispatch
      - belt-worker
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_keepalive == 'true' &&
      needs.keepalive-prep.outputs.trace != '' &&
      needs.keepalive-prep.outputs.pr_number != '' &&
      needs.belt-dispatch.outputs.issue != '' &&
      needs.belt-dispatch.outputs.branch != '' &&
      needs.belt-worker.result == 'success' &&
      inputs.dry_run != 'true'
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
      pull-requests: write
    outputs:
      action: ${{ steps.reconcile.outputs.action || '' }}
      changed: ${{ steps.reconcile.outputs.changed || 'false' }}
      mode: ${{ steps.reconcile.outputs.mode || '' }}
      merged_sha: ${{ steps.reconcile.outputs.merged_sha || '' }}
      success: ${{ steps.reconcile.outputs.success || '' }}
      status: ${{ steps.reconcile.outputs.status || '' }}
      status_head: ${{ steps.reconcile.outputs.status_head || '' }}
      status_base: ${{ steps.reconcile.outputs.status_base || '' }}
      status_mode: ${{ steps.reconcile.outputs.status_mode || '' }}
      link: ${{ steps.reconcile.outputs.link || '-' }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Ensure keepalive sync token available
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token }}
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
        run: |
          if [ -n "${APP_TOKEN}" ]; then
            exit 0
          fi
          if [ -z "${ACTIONS_TOKEN}" ]; then
            echo "::error::Keepalive sync requires App token or ACTIONS_BOT_PAT." >&2
            exit 1
          fi

      - name: Checkout orchestrator scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Reconcile keepalive branch state
        id: reconcile
        uses: actions/github-script@v8
        env:
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          ISSUE_NUMBER: ${{ needs.belt-dispatch.outputs.issue }}
          BASE_BRANCH: ${{ needs.belt-dispatch.outputs.base }}
          PR_BASE_BRANCH: ${{ needs.keepalive-prep.outputs.base_ref }}
          HEAD_BRANCH: ${{ needs.belt-dispatch.outputs.branch }}
          PR_HEAD_BRANCH: ${{ needs.keepalive-prep.outputs.head_ref }}
          HEAD_REPO: ${{ needs.keepalive-prep.outputs.head_repo }}
          PREVIOUS_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head }}
          COMMENT_ID: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_id }}
          COMMENT_URL: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_url }}
          COMMENT_TRACE: ${{ needs.keepalive-prep.outputs.existing_instruction_trace }}
          COMMENT_ROUND: ${{ needs.keepalive-prep.outputs.existing_instruction_round }}
          AGENT_ALIAS: ${{ needs.keepalive-prep.outputs.agent || needs.keepalive-guard.outputs.agent_alias }}
          TTL_SHORT_MS: 90000
          POLL_SHORT_MS: 5000
          TTL_LONG_MS: 240000
          POLL_LONG_MS: 5000
          SYNC_LABEL: agents:sync-required
          DEBUG_LABEL: agents:debug
          DISPATCH_EVENT_TYPE: codex-pr-comment-command
          AUTOMATION_LOGINS: chatgpt-codex-connector,stranske-automation-bot

          MERGE_METHOD: squash
          DELETE_TEMP_BRANCH: 'true'
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT }}
          script: |
            const { runKeepalivePostWork } = require('./.github/scripts/keepalive_post_work.js');
            await runKeepalivePostWork({ core, github, context, env: process.env });

  keepalive-instruction:
    name: Post keepalive instruction
    needs:
      - keepalive-guard
      - keepalive-cap
      - keepalive-prep
      - keepalive-post-work
    if: |
      always() &&
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.enable_keepalive == 'true' &&
      needs.keepalive-cap.outputs.ok == 'true'
    runs-on: ubuntu-latest
    outputs:
      round: ${{ needs.keepalive-prep.outputs.round || '' }}
      trace: ${{ needs.keepalive-prep.outputs.trace || '' }}
      author: ${{ steps.capture_comment.outputs.author || steps.author_token.outputs.author || '' }}
      dispatch_mode: ${{ needs.keepalive-prep.outputs.dispatch_mode || '' }}
      comment_id: ${{ steps.capture_comment.outputs.comment_id || '' }}
      comment_url: ${{ steps.capture_comment.outputs.comment_url || '' }}
      acknowledged: ${{ steps.ack.outputs.acknowledged || 'false' }}
      actions_available: ${{ needs.keepalive-prep.outputs.actions_available || 'false' }}
      pr_number: ${{ needs.keepalive-prep.outputs.pr_number || '' }}
      baseline_head: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
      head_ref: ${{ needs.keepalive-prep.outputs.head_ref || '' }}
      base_ref: ${{ needs.keepalive-prep.outputs.base_ref || '' }}
      agent: ${{ needs.keepalive-prep.outputs.agent || '' }}
      should_post: ${{ steps.gate.outputs.should_post || 'false' }}
      skip_reason: ${{ steps.gate.outputs.skip_reason || '' }}
    steps:
      - name: Evaluate instruction gating
        id: gate
        run: |
          set -euo pipefail
          : "${POST_WORK_RESULT:=}"
          : "${POST_WORK_SUCCESS:=}"
          : "${POST_WORK_CHANGED:=}"
          : "${DRY_RUN:=}"
          : "${EXISTING_ROUND:=}"
          : "${EXISTING_TRACE:=}"
          : "${EXISTING_REACTION:=}"
          : "${EXISTING_COMMENT_ID:=}"
          : "${EXISTING_COMMENT_URL:=}"
          : "${CURRENT_ROUND:=}"
          : "${CURRENT_TRACE:=}"
          result="${POST_WORK_RESULT}";
          success="${POST_WORK_SUCCESS}";
          changed="${POST_WORK_CHANGED}";
          dry_run="${DRY_RUN}";
          existing_round="${EXISTING_ROUND}"
          existing_trace="${EXISTING_TRACE}"
          existing_reaction="${EXISTING_REACTION}"
          existing_comment_id="${EXISTING_COMMENT_ID}"
          existing_comment_url="${EXISTING_COMMENT_URL}"
          current_round="${CURRENT_ROUND}"
          current_trace="${CURRENT_TRACE}"
          should_post='false'
          reason='post-work-unavailable'

          if [ "${result}" = 'success' ] && [ "${success}" = 'true' ] && [ "${changed}" = 'true' ]; then
            should_post='true'
            reason=''
          elif [ "${result}" = 'success' ] && [ "${success}" = 'true' ]; then
            reason='branch-not-advanced'
          elif [ "${result}" = 'skipped' ] && [ "${dry_run}" = 'true' ]; then
            reason='dry-run'
          elif [ -z "${result}" ] && [ "${dry_run}" = 'true' ]; then
            reason='dry-run'
          elif [ -z "${result}" ]; then
            reason='post-work-not-run'
          else
            reason="${result}"
          fi

          if [ "${should_post}" = 'true' ]; then
            if [ -n "${existing_round}" ] && [ -n "${current_round}" ] && [ "${existing_round}" = "${current_round}" ]; then
              same_trace='false'
              if [ -n "${existing_trace}" ] && [ -n "${current_trace}" ] && [ "${existing_trace}" = "${current_trace}" ]; then
                same_trace='true'
              fi
              if [ "${same_trace}" = 'true' ] || [ "${existing_reaction}" = 'true' ]; then
                should_post='false'
                reason='existing-instruction'
              fi
            fi
          fi

          {
            echo "should_post=${should_post}"
            echo "skip_reason=${reason}"
          } >>"$GITHUB_OUTPUT"

          {
            echo "SHOULD_POST=${should_post}"
            echo "SKIP_REASON=${reason}"
            echo "EXISTING_COMMENT_ID=${existing_comment_id}"
            echo "EXISTING_COMMENT_URL=${existing_comment_url}"
          } >>"$GITHUB_ENV"
        env:
          POST_WORK_RESULT: ${{ needs.keepalive-post-work.result || '' }}
          POST_WORK_SUCCESS: ${{ needs.keepalive-post-work.outputs.success || '' }}
          POST_WORK_CHANGED: ${{ needs.keepalive-post-work.outputs.changed || '' }}
          DRY_RUN: ${{ inputs.dry_run || '' }}
          EXISTING_ROUND: ${{ needs.keepalive-prep.outputs.existing_instruction_round || '' }}
          EXISTING_TRACE: ${{ needs.keepalive-prep.outputs.existing_instruction_trace || '' }}
          EXISTING_REACTION: ${{ needs.keepalive-prep.outputs.existing_instruction_reaction || 'false' }}
          EXISTING_COMMENT_ID: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_id || '' }}
          EXISTING_COMMENT_URL: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_url || '' }}
          CURRENT_ROUND: ${{ needs.keepalive-prep.outputs.round || '' }}
          CURRENT_TRACE: ${{ needs.keepalive-prep.outputs.trace || '' }}

      - name: Checkout orchestrator scripts
        if: steps.gate.outputs.should_post == 'true'
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Mint GitHub App token (preferred)
        id: app_token
        if: steps.gate.outputs.should_post == 'true'
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Select keepalive author token
        id: author_token
        if: steps.gate.outputs.should_post == 'true'
        shell: bash
        env:
          PREFLIGHT_TOKEN: ${{ inputs.token_source || '' }}
          APP_TOKEN_AVAILABLE: ${{ steps.app_token.outputs.token && 'true' || 'false' }}
        run: |
          set -euo pipefail
          token="${PREFLIGHT_TOKEN}"
          if [ "${token}" = 'APP_TOKEN' ] && [ "${APP_TOKEN_AVAILABLE}" = 'true' ]; then
            echo "token=APP_TOKEN" >>"$GITHUB_OUTPUT"
            echo "author=agents-workflows-bot[bot]" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "${token}" = 'ACTIONS_BOT_PAT' ]; then
            echo "token=ACTIONS_BOT_PAT" >>"$GITHUB_OUTPUT"
            echo "author=stranske" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "${token}" = 'SERVICE_BOT_PAT' ]; then
            echo "token=SERVICE_BOT_PAT" >>"$GITHUB_OUTPUT"
            echo "author=stranske-automation-bot" >>"$GITHUB_OUTPUT"
            exit 0
          fi

          echo "token=" >>"$GITHUB_OUTPUT"
          echo "author=" >>"$GITHUB_OUTPUT"
          echo "::error::Token preflight did not select a valid keepalive author token." >&2
          exit 1

      - name: Enforce keepalive author invariant
        id: author_invariant
        if: steps.gate.outputs.should_post == 'true'
        env:
          SELECTED_TOKEN: ${{ steps.author_token.outputs.token || '' }}
        run: |
          set -euo pipefail
          case "${SELECTED_TOKEN}" in
            'APP_TOKEN'|'ACTIONS_BOT_PAT'|'SERVICE_BOT_PAT')
              exit 0 ;;
            *)
              echo "::error::Keepalive instruction must post with App token or PAT. Selected token: ${SELECTED_TOKEN:-none}." >&2
              exit 1 ;;
          esac

      - name: Post keepalive instruction (App token preferred)
        id: post_instruction_app
        if: steps.gate.outputs.should_post == 'true' && steps.author_token.outputs.token == 'APP_TOKEN'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_BODY: ${{ needs.keepalive-prep.outputs.body }}
        with:
          github-token: ${{ steps.app_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(issueNumber) || issueNumber <= 0) {
              core.setFailed('Keepalive instruction missing pull request number.');
              return;
            }
            const body = process.env.COMMENT_BODY || '';
            if (!body.trim()) {
              core.setFailed('Keepalive instruction body is empty.');
              return;
            }
            const { data: comment } = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body,
            });
            core.setOutput('comment-id', comment?.id ? String(comment.id) : '');
            core.setOutput('comment-url', comment?.html_url || '');
            core.setOutput('comment-author', comment?.user?.login || '');

      - name: Post keepalive instruction (as stranske if possible)
        id: post_instruction_primary
        if: steps.gate.outputs.should_post == 'true' && steps.author_token.outputs.token == 'ACTIONS_BOT_PAT'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_BODY: ${{ needs.keepalive-prep.outputs.body }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(issueNumber) || issueNumber <= 0) {
              core.setFailed('Keepalive instruction missing pull request number.');
              return;
            }
            const body = process.env.COMMENT_BODY || '';
            if (!body.trim()) {
              core.setFailed('Keepalive instruction body is empty.');
              return;
            }
            const { data: comment } = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body,
            });
            core.setOutput('comment-id', comment?.id ? String(comment.id) : '');
            core.setOutput('comment-url', comment?.html_url || '');
            core.setOutput('comment-author', comment?.user?.login || '');

      - name: Post keepalive instruction (fallback)
        id: post_instruction_fallback
        if: steps.gate.outputs.should_post == 'true' && steps.author_token.outputs.token == 'SERVICE_BOT_PAT'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_BODY: ${{ needs.keepalive-prep.outputs.body }}
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(issueNumber) || issueNumber <= 0) {
              core.setFailed('Keepalive instruction missing pull request number.');
              return;
            }
            const body = process.env.COMMENT_BODY || '';
            if (!body.trim()) {
              core.setFailed('Keepalive instruction body is empty.');
              return;
            }
            const { data: comment } = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body,
            });
            core.setOutput('comment-id', comment?.id ? String(comment.id) : '');
            core.setOutput('comment-url', comment?.html_url || '');
            core.setOutput('comment-author', comment?.user?.login || '');

      - name: Capture instruction comment metadata
        id: capture_comment
        if: steps.gate.outputs.should_post == 'true'
        shell: bash
        run: |
          set -euo pipefail
          selected_token="${{ steps.author_token.outputs.token }}"
          case "${selected_token}" in
            'APP_TOKEN')
              comment_id="${{ steps.post_instruction_app.outputs.comment-id || '' }}"
              comment_url="${{ steps.post_instruction_app.outputs.comment-url || '' }}"
              comment_author="${{ steps.post_instruction_app.outputs.comment-author || '' }}"
              ;;
            'ACTIONS_BOT_PAT')
              comment_id="${{ steps.post_instruction_primary.outputs.comment-id || '' }}"
              comment_url="${{ steps.post_instruction_primary.outputs.comment-url || '' }}"
              comment_author="${{ steps.post_instruction_primary.outputs.comment-author || '' }}"
              ;;
            *)
              comment_id="${{ steps.post_instruction_fallback.outputs.comment-id || '' }}"
              comment_url="${{ steps.post_instruction_fallback.outputs.comment-url || '' }}"
              comment_author="${{ steps.post_instruction_fallback.outputs.comment-author || '' }}"
              ;;
          esac

          if [ -z "${comment_id}" ]; then
            echo "::error::Keepalive instruction comment was not created." >&2
            exit 1
          fi

          expected_author='${{ steps.author_token.outputs.author || '' }}'
          if [ -n "${comment_author}" ] && [ -n "${expected_author}" ] && [ "${comment_author}" != "${expected_author}" ]; then
            echo "::error::Keepalive instruction posted as ${comment_author}, expected ${expected_author}." >&2
            exit 1
          fi

          resolved_author="${comment_author:-${expected_author}}"

          echo "comment_id=${comment_id}" >>"$GITHUB_OUTPUT"
          echo "comment_url=${comment_url}" >>"$GITHUB_OUTPUT"
          echo "COMMENT_ID=${comment_id}" >>"$GITHUB_ENV"
          echo "COMMENT_URL=${comment_url}" >>"$GITHUB_ENV"
          echo "author=${resolved_author}" >>"$GITHUB_OUTPUT"
          echo "AUTHOR=${resolved_author}" >>"$GITHUB_ENV"

      - name: Ack keepalive instruction
        id: ack
        if: steps.gate.outputs.should_post == 'true'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id }}
          EXPECTED_AUTHOR: ${{ steps.author_token.outputs.author || '' }}
        with:
          github-token: ${{ steps.author_token.outputs.token == 'APP_TOKEN' && steps.app_token.outputs.token || (steps.author_token.outputs.token == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT) }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const commentId = Number(process.env.COMMENT_ID || 0);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setFailed('Keepalive instruction comment id missing.');
              return;
            }

            const { owner, repo } = context.repo;
            const expectedAuthor = normalise(process.env.EXPECTED_AUTHOR).toLowerCase();

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'hooray',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add ðŸ¥³ reaction to keepalive comment ${commentId}: ${message}`);
            }

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'eyes',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add ðŸ‘€ reaction to keepalive comment ${commentId}: ${message}`);
            }

            let commentTimestamp = 0;
            let commentAuthor = '';
            try {
              const { data: commentDetails } = await github.rest.issues.getComment({ owner, repo, comment_id: commentId });
              commentTimestamp = Date.parse(commentDetails?.updated_at || commentDetails?.created_at || '') || 0;
              commentAuthor = normalise(commentDetails?.user?.login);
              if (expectedAuthor && commentAuthor && commentAuthor.toLowerCase() !== expectedAuthor) {
                core.setFailed(
                  `Keepalive instruction author mismatch: expected ${expectedAuthor}, received ${commentAuthor}.`
                );
                return;
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to fetch keepalive comment ${commentId} metadata: ${message}`);
            }

            if (commentAuthor) {
              core.setOutput('author_login', commentAuthor);
            }

            const deadline = Date.now() + 180_000;
            const pollDelay = 5_000;
            const runPollInterval = 15_000;
            let lastRunCheck = 0;
            let acknowledged = false;
            let ackSource = '';

            const checkWorkflowRuns = async () => {
              try {
                const response = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: 'agents-pr-meta.yml',
                  event: 'issue_comment',
                  per_page: 20,
                });
                const runs = Array.isArray(response?.data?.workflow_runs) ? response.data.workflow_runs : [];
                for (const run of runs) {
                  const startedAt = Date.parse(run?.run_started_at || run?.created_at || '') || 0;
                  if (commentTimestamp && startedAt && startedAt + 5000 < commentTimestamp) {
                    continue;
                  }
                  const status = String(run?.status || '').toLowerCase();
                  const conclusion = String(run?.conclusion || '').toLowerCase();
                  if (status === 'completed' && conclusion === 'success') {
                    return true;
                  }
                }
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to inspect PR-meta workflow runs for comment ${commentId}: ${message}`);
              }
              return false;
            };

            while (Date.now() < deadline) {
              const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                owner,
                repo,
                comment_id: commentId,
                per_page: 100,
              });
              if (reactions.some((reaction) => (reaction?.content || '').toLowerCase() === 'rocket')) {
                acknowledged = true;
                ackSource = 'reaction';
                break;
              }

              if (Date.now() - lastRunCheck >= runPollInterval) {
                lastRunCheck = Date.now();
                const runAck = await checkWorkflowRuns();
                if (runAck) {
                  acknowledged = true;
                  ackSource = 'pr-meta';
                  break;
                }
              }

              await new Promise((resolve) => setTimeout(resolve, pollDelay));
            }

            core.setOutput('acknowledged', acknowledged ? 'true' : 'false');
            core.setOutput('ack_source', ackSource);

      - name: Emit fallback dispatch
        if: steps.gate.outputs.should_post == 'true' && steps.ack.outputs.acknowledged != 'true' && needs.keepalive-prep.outputs.actions_available == 'true'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id }}
          COMMENT_URL: ${{ steps.capture_comment.outputs.comment_url }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ISSUE_NUMBER: ${{ inputs.dispatcher_force_issue }}
          DISPATCH_MODE: ${{ needs.keepalive-prep.outputs.dispatch_mode }}
          AGENT_ALIAS: ${{ needs.keepalive-prep.outputs.agent }}
          INSTRUCTION_BODY: ${{ needs.keepalive-prep.outputs.instruction_body }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const commentId = Number(process.env.COMMENT_ID || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0 || !Number.isFinite(commentId) || commentId <= 0) {
              core.warning('Skipping fallback dispatch: pull request or comment id unavailable.');
              return;
            }

            const { owner, repo } = context.repo;
            let base = '';
            let head = '';
            let issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            let forked = false;

            try {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              base = pr?.base?.ref || '';
              head = pr?.head?.ref || '';
              const headRepo = pr?.head?.repo?.full_name || '';
              const forkFlag = pr?.head?.repo?.fork;
              const repoFullName = `${owner}/${repo}`.toLowerCase();
              if (forkFlag || (headRepo && headRepo.toLowerCase() !== repoFullName)) {
                forked = true;
              }
              if (!issueNumber) {
                const match = (pr?.head?.ref || '').match(/issue-+(\d+)/i);
                if (match) {
                  issueNumber = Number.parseInt(match[1], 10);
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to resolve pull request context for fallback dispatch: ${message}`);
            }

            if (!base || !head) {
              core.warning('Fallback dispatch skipped: unable to determine base/head.');
              return;
            }

            if (forked) {
              core.info('Fallback dispatch skipped: pull request originates from a fork.');
              return;
            }

            const instructionBody = (process.env.INSTRUCTION_BODY || '').trim();
            if (!instructionBody) {
              core.info('Fallback dispatch skipped: instruction segment unavailable.');
              return;
            }

            // GitHub repository_dispatch limits client_payload to 10 top-level properties.
            // Nest auxiliary data under `meta` to stay within the limit.
            const payload = {
              issue: issueNumber || prNumber,
              base,
              head,
              agent: (process.env.AGENT_ALIAS || '').trim() || 'codex',
              instruction_body: instructionBody,
              dispatch_mode: process.env.DISPATCH_MODE || '',
              meta: {
                comment_id: commentId,
                comment_url: process.env.COMMENT_URL || '',
                round: process.env.ROUND || '',
                trace: process.env.TRACE || '',
              },
              quiet: true,
              reply: 'none',
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: payload,
            });

      - name: Post fallback comment
        if: steps.gate.outputs.should_post == 'true' && steps.ack.outputs.acknowledged != 'true'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
        with:
          github-token: ${{ steps.author_token.outputs.token == 'APP_TOKEN' && steps.app_token.outputs.token || (steps.author_token.outputs.token == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT) }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Unable to post fallback comment: missing PR number.');
              return;
            }

            const { owner, repo } = context.repo;
            const body = `**Keepalive ${process.env.ROUND || '?' }** \`${process.env.TRACE || ''}\` fallback: PR-meta ack not observed in TTL â€“ emitted connector dispatch.`;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });

      - name: Record instruction observability line
        if: always()
        shell: bash
        env:
          SHOULD_POST: ${{ steps.gate.outputs.should_post || 'false' }}
          SKIP_REASON: ${{ steps.gate.outputs.skip_reason || '' }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace || '' }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
          AUTHOR: ${{ steps.ack.outputs.author_login || steps.capture_comment.outputs.author || steps.author_token.outputs.author || '' }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id || '' }}
          ACKNOWLEDGED: ${{ steps.ack.outputs.acknowledged || '' }}
          AUTHOR_TOKEN: ${{ steps.author_token.outputs.token || '' }}
          AUTHOR_INVARIANT_OUTCOME: ${{ steps.author_invariant.outcome || '' }}
          POST_PRIMARY_OUTCOME: ${{ steps.post_instruction_primary.outcome || '' }}
          POST_FALLBACK_OUTCOME: ${{ steps.post_instruction_fallback.outcome || '' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi
          head="${BASELINE_HEAD:-}"
          if [ -n "${head}" ]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi

          should_post="${SHOULD_POST:-false}"
          comment_id="${COMMENT_ID:-}"
          author="${AUTHOR:-}"
          if [ -z "${author}" ]; then
            author='none'
          fi
          ack_state="${ACKNOWLEDGED:-}"
          if [ "${ack_state}" = 'true' ]; then
            ack='ok'
          else
            ack='fail'
          fi

          if [ "${should_post}" != 'true' ]; then
            reason="${SKIP_REASON:-unknown}"
            printf 'INSTRUCTION: ok=false author=%s comment=none ack=fail head=%s trace=%s reason=%s\n' \
              "${author}" "${head}" "${trace}" "${reason:-unknown}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ "${AUTHOR_INVARIANT_OUTCOME}" = 'failure' ]; then
            token="${AUTHOR_TOKEN:-}"
            if [ -z "${token}" ]; then
              token='github.token'
            fi
            printf 'INSTRUCTION: ok=false author=none comment=none ack=fail head=%s trace=%s reason=wrong-author token=%s\n' \
              "${head}" "${trace}" "${token}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ -n "${comment_id}" ]; then
            printf 'INSTRUCTION: ok=true author=%s comment=%s ack=%s head=%s trace=%s\n' \
              "${author}" "${comment_id}" "${ack}" "${head}" "${trace}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          reason='unknown'
          if [ "${POST_PRIMARY_OUTCOME}" = 'failure' ] || [ "${POST_FALLBACK_OUTCOME}" = 'failure' ]; then
            reason='post-error'
          fi
          printf 'INSTRUCTION: ok=false author=%s comment=none ack=fail head=%s trace=%s reason=%s\n' \
            "${author}" "${head}" "${trace}" "${reason}" >>"$GITHUB_STEP_SUMMARY"

  belt-dispatch-summary:
    name: Summarise Codex dispatch outcomes
    needs:
      - belt-dispatch
      - belt-worker
      - belt-check-existing-pr
      - keepalive-guard
      - keepalive-cap
      - keepalive-prep
      - keepalive-instruction
      - keepalive-post-work
      - dry-run-branch-sync
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Emit worker observability line
        if: always()
        shell: bash
        env:
          PROCEED: ${{ needs.keepalive-guard.outputs.proceed || 'false' }}
          CAP_OK: ${{ needs.keepalive-cap.outputs.ok || 'false' }}
          SHOULD_POST: ${{ needs.keepalive-instruction.outputs.should_post || 'false' }}
          COMMENT_ID: ${{ needs.keepalive-instruction.outputs.comment_id || '' }}
          TRACE: ${{ needs.keepalive-instruction.outputs.trace || needs.keepalive-prep.outputs.trace || inputs.keepalive_trace || '' }}
          PR_NUMBER: ${{ needs.keepalive-instruction.outputs.pr_number || needs.keepalive-prep.outputs.pr_number || inputs.keepalive_pr || '' }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          INSTRUCTION_RESULT: ${{ needs.keepalive-instruction.result || '' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi

          pr_value='?'
          if [ -n "${PR_NUMBER}" ]; then
            pr_value="${PR_NUMBER}"
          fi
          pr_label="#${pr_value}"

          head="${BASELINE_HEAD:-}"
          if [ -n "${head}" ]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi

          instr="${COMMENT_ID:-}"
          if [ -z "${instr}" ]; then
            instr='none'
          fi

          action='skip'
          reason='blocked'
          worker_result="${WORKER_RESULT:-}"

          if [ "${PROCEED}" != 'true' ]; then
            reason='blocked'
          elif [ "${CAP_OK}" != 'true' ]; then
            reason='cap-reached'
          elif [ "${worker_result}" = 'success' ]; then
            action='execute'
            reason='new-instruction'
          elif [ "${worker_result}" = 'failure' ]; then
            action='execute'
            reason='blocked'
          elif [ "${SHOULD_POST}" = 'true' ]; then
            reason='blocked'
          else
            reason='no-new-instruction-and-head-unchanged'
          fi

          printf 'WORKER: action=%s reason=%s pr=%s head=%s instr=%s trace=%s\n' \
            "${action}" "${reason}" "${pr_label}" "${head}" "${instr}" "${trace}" >>"$GITHUB_STEP_SUMMARY"

      - name: Emit sync observability line
        if: always()
        shell: bash
        env:
          TRACE: ${{ needs.keepalive-instruction.outputs.trace || needs.keepalive-prep.outputs.trace || inputs.keepalive_trace || '' }}
          ACTION: ${{ needs.keepalive-post-work.outputs.action || '' }}
          CHANGED: ${{ needs.keepalive-post-work.outputs.changed || 'false' }}
          LINK: ${{ needs.keepalive-post-work.outputs.link || '-' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi
          action="${ACTION:-}"
          if [ -z "${action}" ]; then
            action='skip'
          fi
          head_changed='false'
          if [ "${CHANGED}" = 'true' ]; then
            head_changed='true'
          fi
            link="${LINK:-}"
            if [ -z "${link}" ]; then
              link='-'
            fi
            printf 'SYNC: action=%s head_changed=%s link=%s trace=%s\n' "${action}" "${head_changed}" "${link}" "${trace}" >>"$GITHUB_STEP_SUMMARY"

      - name: Record existing PR guard outcome
        if: needs.belt-check-existing-pr.outputs.pr_exists == 'true' && inputs.enable_keepalive != 'true'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker guard
          * Status: skipped: PR exists.
          * Existing PR: [#${{ needs.belt-check-existing-pr.outputs.pr_number }}](${{ needs.belt-check-existing-pr.outputs.pr_url }})
          EOF

      - name: Highlight worker failure
        if: needs.belt-worker.result == 'failure'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker
          * Result: failure â€“ see Agents 72 logs for details.
          EOF

      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Append dispatch summary
        uses: actions/github-script@v8
        env:
          DISPATCH_RESULT: ${{ needs.belt-dispatch.result || '' }}
          DISPATCH_ISSUE: ${{ needs.belt-dispatch.outputs.issue || '' }}
          DISPATCH_REASON: ${{ needs.belt-dispatch.outputs.reason || '' }}
          WORKER_RESULT: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && inputs.enable_keepalive != 'true') && 'skipped: PR exists.' || needs.belt-worker.result || '' }}"
          WORKER_ALLOWED: ${{ needs.belt-worker.outputs.allowed || '' }}
          WORKER_PR_NUMBER: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && inputs.enable_keepalive != 'true') && needs.belt-check-existing-pr.outputs.pr_number || needs.belt-worker.outputs.pr_number || needs.keepalive-instruction.outputs.pr_number || inputs.keepalive_pr || '' }}"
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
          KEEPALIVE_ACTION: ${{ needs.belt-worker.outputs.keepalive_action || '' }}
          KEEPALIVE_REASON: ${{ needs.belt-worker.outputs.keepalive_reason || '' }}
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { appendDispatchSummary } = require('./.github/scripts/agents_dispatch_summary.js');
            await appendDispatchSummary({ core, context, env: process.env });

      - name: Record keepalive worker outcome
        if: |
          needs.keepalive-guard.outputs.proceed != 'false' &&
          needs.keepalive-instruction.outputs.trace != ''
        uses: actions/github-script@v8
        env:
          KEEPALIVE_TRACE: ${{ needs.keepalive-instruction.outputs.trace }}
          KEEPALIVE_ROUND: ${{ needs.keepalive-instruction.outputs.round || inputs.keepalive_round }}
          KEEPALIVE_PR: ${{ needs.keepalive-instruction.outputs.pr_number || needs.belt-worker.outputs.pr_number || inputs.keepalive_pr || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
          KEEPALIVE_ACTION: ${{ needs.belt-worker.outputs.keepalive_action || '' }}
          KEEPALIVE_REASON: ${{ needs.belt-worker.outputs.keepalive_reason || '' }}
          KEEPALIVE_HEAD_SHA: ${{ needs.belt-worker.outputs.keepalive_head_sha || '' }}
          KEEPALIVE_LAST_INSTRUCTION_ID: ${{ needs.belt-worker.outputs.keepalive_last_instruction_id || '' }}
          KEEPALIVE_LAST_INSTRUCTION_HEAD: ${{ needs.belt-worker.outputs.keepalive_last_instruction_head_sha || '' }}
        with:
          github-token: ${{ steps.app_token.outputs.token || secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const trace = normalise(process.env.KEEPALIVE_TRACE);
            const round = normalise(process.env.KEEPALIVE_ROUND);
            const workerResult = normalise(process.env.WORKER_RESULT) || 'unknown';
            const branch = normalise(process.env.WORKER_BRANCH);
            const dryRun = normalise(process.env.WORKER_DRY_RUN).toLowerCase() === 'true';
            const prCandidate = normalise(process.env.KEEPALIVE_PR);
            const prNumber = Number(prCandidate);
            const { owner, repo } = context.repo;

            let headSha = '';
            if (branch) {
              try {
                const { data } = await github.rest.repos.getBranch({ owner, repo, branch });
                headSha = data?.commit?.sha || '';
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Unable to determine head SHA for ${branch}: ${message}`);
              }
            }

            if (!headSha) {
              headSha = normalise(process.env.KEEPALIVE_HEAD_SHA);
            }

            const keepaliveAction = normalise(process.env.KEEPALIVE_ACTION) || 'unknown';
            const keepaliveReason = normalise(process.env.KEEPALIVE_REASON);
            const lastInstructionId = normalise(process.env.KEEPALIVE_LAST_INSTRUCTION_ID);
            const lastInstructionHead = normalise(process.env.KEEPALIVE_LAST_INSTRUCTION_HEAD);

            const summary = core.summary;
            summary
              .addHeading('Keepalive worker outcome')
              .addTable([
                [
                  { data: 'Round', header: true },
                  { data: 'Trace', header: true },
                  { data: 'Result', header: true },
                  { data: 'Head SHA', header: true }
                ],
                [
                  round || 'â€”',
                  trace || 'â€”',
                  workerResult,
                  headSha || '(unavailable)'
                ]
              ])
              .addTable([
                [
                  { data: 'Action', header: true },
                  { data: 'Reason', header: true },
                  { data: 'Last Instruction', header: true },
                  { data: 'Last Head SHA', header: true }
                ],
                [
                  keepaliveAction,
                  keepaliveReason || 'â€”',
                  lastInstructionId || 'â€”',
                  lastInstructionHead ? lastInstructionHead.slice(0, 12) : 'â€”'
                ]
              ])
              .write();

            if (!trace) {
              core.info('No keepalive trace detected; skipping worker outcome comment.');
              return;
            }

            if (!prNumber || !Number.isFinite(prNumber)) {
              core.info('No PR number resolved for keepalive worker outcome; skipping comment.');
              return;
            }

            const loweredResult = workerResult.toLowerCase();
            const shouldComment = headSha || loweredResult !== 'skipped';

            if (!shouldComment) {
              core.info('Keepalive worker skipped; no outcome comment posted.');
              return;
            }

            const shortSha = headSha ? headSha.slice(0, 12) : 'unknown';
            let details = `worker ${workerResult}`;
            if (dryRun) {
              details += ' (dry run)';
            }
            if (headSha) {
              details += ` â€“ head ${shortSha}`;
            }

            const body = `**Keepalive ${round || '?'}** \`${trace}\` worker: ${details}.`;

            try {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body,
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to post keepalive worker outcome for PR #${prNumber}: ${message}`);
            }

      - name: Record branch-sync validation outcome
        if: needs.dry-run-branch-sync.result == 'success'
        env:
          RUN_URL: ${{ needs.dry-run-branch-sync.outputs.run_url }}
          CONCLUSION: ${{ needs.dry-run-branch-sync.outputs.run_conclusion }}
          HEAD_UPDATED: ${{ needs.dry-run-branch-sync.outputs.head_updated }}
          NEW_HEAD: ${{ needs.dry-run-branch-sync.outputs.new_head }}
          PR_URL: ${{ needs.dry-run-branch-sync.outputs.pr_url }}
        run: |
          head_change='unchanged'
          if [ "${HEAD_UPDATED}" = 'true' ] && [ -n "${NEW_HEAD}" ]; then
            head_change="advanced to ${NEW_HEAD:0:12}"
          fi

          sync_link='(not available)'
          if [ -n "${RUN_URL}" ]; then
            sync_link="[run](${RUN_URL})"
          fi

          pr_link='(n/a)'
          if [ -n "${PR_URL}" ]; then
            pr_link="[link](${PR_URL})"
          fi

          cat <<EOF >>"$GITHUB_STEP_SUMMARY"
          ## Branch-sync validation (dry-run)
          * Result: ${CONCLUSION:-unknown}
          * Workflow: ${sync_link}
          * PR: ${pr_link}
          * Head change: ${head_change}
          EOF
  belt-scan-ready-prs:
    name: Scan Codex promotion queue
    needs:
      - keepalive-guard
    runs-on: ubuntu-latest
    outputs:
      items: ${{ steps.scan.outputs.items || '[]' }}
    env:
      MAX_PROMOTIONS: ${{ inputs.conveyor_max_merges }}
    steps:
      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Identify ready Codex PRs
        id: scan
        uses: actions/github-script@v8
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { identifyReadyCodexPRs } = require('./.github/scripts/agents_belt_scan.js');
            await identifyReadyCodexPRs({ github, context, core, env: process.env });

  belt-conveyor:
    name: Promote Codex PRs
    needs:
      - belt-scan-ready-prs
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      inputs.conveyor_max_merges != '0' &&
      needs.belt-scan-ready-prs.outputs.items != '' &&
      needs.belt-scan-ready-prs.outputs.items != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.belt-scan-ready-prs.outputs.items) }}
    uses: ./.github/workflows/agents-73-codex-belt-conveyor.yml
    with:
      issue: ${{ matrix.pr.issue || 0 }}
      branch: ${{ matrix.pr.branch }}
      pr_number: ${{ matrix.pr.pr }}
      head_sha: ${{ matrix.pr.head_sha }}
      dry_run: ${{ inputs.dry_run == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  automerge-agent-prs:
    name: Auto-merge labelled agent PRs
    needs:
      - belt-conveyor
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false' && inputs.dry_run != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Merge Codex PRs tagged for automerge
        id: automerge
        uses: actions/github-script@v8
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || '' }}
          AUTOMERGE_LABEL: automerge
          AUTOMATION_USERS: ${{ inputs.codex_user }}
        with:
          github-token: ${{ secrets.OWNER_PR_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const label = (process.env.AUTOMERGE_LABEL || 'automerge').trim();
            const summary = core.summary;
            const { owner, repo } = context.repo;

            let defaultBranch = (process.env.DEFAULT_BRANCH || '').trim();
            if (!defaultBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.default_branch || 'main';
            }

            const automationUsersRaw = process.env.AUTOMATION_USERS || '';
            const automationUsers = automationUsersRaw
              .split(',')
              .map((login) => login.trim())
              .filter(Boolean);
            if (!automationUsers.length) {
              automationUsers.push('stranske-automation-bot');
            }

            async function loadPullRequest(pull_number) {
              let attempt = 0;
              while (true) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (!pr) {
                  return null;
                }
                const state = (pr.mergeable_state || '').toLowerCase();
                if (state && state !== 'unknown') {
                  return pr;
                }
                attempt += 1;
                if (attempt >= 2) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', labels: label, per_page: 100 }
            );

            const rows = [];
            const merged = [];

            summary.addHeading('Agent auto-merge scan');
            if (!issues.length) {
              summary.addRaw(`No open pull requests carry the "${label}" label.`).addEOL();
              await summary.write();
              core.setOutput('merged', JSON.stringify(merged));
              return;
            }

            for (const issue of issues) {
              if (!issue || !issue.pull_request) {
                continue;
              }

              const prNumber = Number(issue.number);
              let note = '';
              let status = 'skipped';

              try {
                const pr = await loadPullRequest(prNumber);
                if (!pr) {
                  note = 'Unable to load pull request data.';
                } else {
                  const author = pr.user && pr.user.login ? pr.user.login : '';
                  if (!automationUsers.includes(author)) {
                    note = `Author @${author || 'unknown'} is not an automation account.`;
                  } else if ((pr.base && pr.base.ref) !== defaultBranch) {
                    note = `Base branch ${pr.base && pr.base.ref ? pr.base.ref : '(unknown)'} does not match ${defaultBranch}.`;
                  } else if (pr.draft) {
                    note = 'Draft pull requests are not eligible for auto-merge.';
                  } else {
                    const mergeableState = (pr.mergeable_state || '').toLowerCase();
                    if (['blocked', 'dirty', 'draft'].includes(mergeableState)) {
                      if (mergeableState === 'blocked') {
                        note = 'Branch protection blocks the merge (mergeable_state=blocked).';
                      } else if (mergeableState === 'dirty') {
                        note = 'Merge conflicts detected (mergeable_state=dirty).';
                      } else {
                        note = `Mergeable state ${mergeableState} prevents auto-merge.`;
                      }
                    } else {
                      const headSha = pr.head && pr.head.sha ? pr.head.sha : '';
                      if (!headSha) {
                        note = 'Missing head SHA for pull request.';
                      } else {
                        const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                          owner,
                          repo,
                          ref: headSha
                        });
                        if (!combined || combined.state !== 'success') {
                          note = 'Required status checks have not all succeeded.';
                        } else {
                          let checksOk = true;
                          let failingCheck = '';
                          try {
                            const { data: checks } = await github.rest.checks.listForRef({
                              owner,
                              repo,
                              ref: headSha,
                              per_page: 100
                            });
                            const checkRuns = Array.isArray(checks.check_runs) ? checks.check_runs : [];
                            for (const run of checkRuns) {
                              const conclusion = (run.conclusion || '').toLowerCase();
                              const statusName = run.name || run.id || 'unknown check';
                              if (!conclusion && run.status !== 'completed') {
                                checksOk = false;
                                failingCheck = `${statusName} pending`;
                                break;
                              }
                              if (conclusion && !['success', 'neutral', 'skipped'].includes(conclusion)) {
                                checksOk = false;
                                failingCheck = `${statusName} concluded ${conclusion}`;
                                break;
                              }
                            }
                          } catch (error) {
                            checksOk = false;
                            failingCheck = `Unable to list check runs: ${error.message || error}`;
                          }

                          if (!checksOk) {
                            note = failingCheck || 'Checks have not completed successfully.';
                          } else {
                            const mergeParams = {
                              owner,
                              repo,
                              pull_number: prNumber,
                              merge_method: 'squash'
                            };
                            try {
                              const response = await github.rest.pulls.merge(mergeParams);
                              if (response && response.data && response.data.merged) {
                                status = 'merged';
                                note = `Merged via ${response.data.merge_method || mergeParams.merge_method}.`;
                                merged.push(prNumber);
                              } else {
                                status = 'error';
                                note = 'Merge API returned an unexpected response.';
                              }
                            } catch (error) {
                              status = 'error';

                              const message = error instanceof Error ? error.message : String(error);
                              const response = error && typeof error === 'object' ? error.response : undefined;
                              const responseData = response && typeof response === 'object' ? response.data : undefined;

                              let details = '';
                              if (responseData && typeof responseData.message === 'string' && responseData.message.trim()) {
                                details = responseData.message.trim();
                              }

                              if (
                                responseData &&
                                Array.isArray(responseData.errors) &&
                                responseData.errors.length
                              ) {
                                const extras = responseData.errors
                                  .map((entry) => {
                                    if (!entry) {
                                      return '';
                                    }
                                    if (typeof entry === 'string') {
                                      return entry;
                                    }
                                    if (typeof entry.message === 'string' && entry.message.trim()) {
                                      return entry.message.trim();
                                    }
                                    try {
                                      return JSON.stringify(entry);
                                    } catch (jsonError) {
                                      return '';
                                    }
                                  })
                                  .filter(Boolean)
                                  .join('; ');
                                if (extras) {
                                  details = details ? `${details} (${extras})` : extras;
                                }
                              }

                              if (!details) {
                                details = message;
                              }

                              const lowered = (details || '').toLowerCase();
                              if (lowered.includes('protected') || lowered.includes('required status check')) {
                                note = `Blocked by branch protection: ${details}`;
                              } else {
                                note = `Merge failed: ${details}`;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } catch (error) {
                status = 'error';
                const message = error instanceof Error ? error.message : String(error);
                note = `Failed to evaluate PR #${prNumber}: ${message}`;
              }

              if (status === 'skipped' && !note) {
                note = 'Auto-merge conditions not satisfied.';
              }

              rows.push([
                `#${prNumber}`,
                status,
                note
              ]);
            }

            if (rows.length) {
              summary.addTable([
                [
                  { data: 'PR', header: true },
                  { data: 'Result', header: true },
                  { data: 'Details', header: true }
                ],
                ...rows
              ]);
            }

            if (!merged.length) {
              summary
                .addRaw('No pull requests were merged automatically during this scan.')
                .addEOL();
            }

            await summary.write();
            core.setOutput('merged', JSON.stringify(merged));
