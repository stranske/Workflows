name: Reusable Codex Run

on:
  workflow_call:
    inputs:
      skip:
        description: 'If true, skip execution entirely. Used for conditional calls.'
        required: false
        default: false
        type: boolean
      prompt_file:
        description: 'Path to the prompt file that Codex should read.'
        required: true
        type: string
      mode:
        description: 'Codex mode for logging purposes (keepalive | autofix | verifier).'
        required: false
        default: keepalive
        type: string
      pr_number:
        description: 'Optional pull request number (used for logging or comments by callers).'
        required: false
        default: ''
        type: string
      max_runtime_minutes:
        description: 'Upper bound for the job runtime in minutes.'
        required: false
        default: 45
        type: number
      sandbox:
        description: 'Sandbox mode to pass through to Codex.'
        required: false
        default: workspace-write
        type: string
      safety_strategy:
        description: 'Safety strategy to pass through to Codex.'
        required: false
        default: drop-sudo
        type: string
      codex_args:
        description: 'Optional Codex CLI arguments (string or JSON array).'
        required: false
        default: ''
        type: string
      appendix:
        description: 'Optional context appended to the prompt passed to Codex.'
        required: false
        default: ''
        type: string
    secrets:
      CODEX_AUTH_JSON:
        description: 'JSON contents of ~/.codex/auth.json for ChatGPT subscription auth'
        required: false
      WORKFLOWS_APP_ID:
        required: false
      WORKFLOWS_APP_PRIVATE_KEY:
        required: false
    outputs:
      final-message:
        description: 'Full Codex output message (base64 encoded)'
        value: ${{ jobs.codex.outputs.final-message }}
      final-message-summary:
        description: 'First 500 chars of Codex output (safe for PR comments)'
        value: ${{ jobs.codex.outputs.final-message-summary }}
      exit-code:
        description: 'Codex CLI exit code (0=success)'
        value: ${{ jobs.codex.outputs.exit-code }}
      changes-made:
        description: 'Whether Codex made file changes (true/false)'
        value: ${{ jobs.codex.outputs.changes-made }}
      commit-sha:
        description: 'SHA of the commit if changes were pushed'
        value: ${{ jobs.codex.outputs.commit-sha }}
      files-changed:
        description: 'Number of files changed by Codex'
        value: ${{ jobs.codex.outputs.files-changed }}

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  codex:
    name: Codex (${{ inputs.mode }})
    runs-on: ubuntu-latest
    environment: agent-standard
    timeout-minutes: ${{ inputs.max_runtime_minutes }}
    if: ${{ !inputs.skip }}
    outputs:
      final-message: ${{ steps.run_codex.outputs.final-message }}
      final-message-summary: ${{ steps.run_codex.outputs.final-message-summary }}
      exit-code: ${{ steps.run_codex.outputs.exit-code }}
      changes-made: ${{ steps.commit.outputs.changes-made }}
      commit-sha: ${{ steps.commit.outputs.commit-sha }}
      files-changed: ${{ steps.commit.outputs.files-changed }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Select auth token
        id: auth_token
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token || '' }}
        run: |
          set -euo pipefail
          checkout_token="${APP_TOKEN:-${GITHUB_TOKEN}}"
          push_token="${APP_TOKEN:-}"
          source="app-token"
          push_allowed="true"

          if [ -z "$push_token" ]; then
            source="github-token"
            push_allowed="false"
          fi

          {
            echo "checkout_token=${checkout_token}"
            echo "push_token=${push_token}"
            echo "source=${source}"
            echo "push_allowed=${push_allowed}"
          } >> "$GITHUB_OUTPUT"

          {
            echo "WORKFLOWS_TOKEN=${checkout_token}"
            echo "CODEX_MODE=${{ inputs.mode }}"
            echo "CODEX_PR_NUMBER=${{ inputs.pr_number }}"
          } >> "$GITHUB_ENV"

          printf 'Checkout auth: %s; push permitted with app token: %s.\n' "$source" "$push_allowed"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.auth_token.outputs.checkout_token }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements*.txt

      - name: Install Python dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            python -m pip install -r requirements.txt
          else
            echo "requirements.txt not found; skipping base requirements install."
          fi

          if [ -f requirements-dev.txt ]; then
            python -m pip install -r requirements-dev.txt
          else
            echo "requirements-dev.txt not found; skipping dev requirements file."
          fi

          if [ -f tools/requirements.txt ]; then
            python -m pip install -r tools/requirements.txt
          else
            echo "tools/requirements.txt not found; skipping tools requirements."
          fi

          if [ -f scripts/requirements.txt ]; then
            python -m pip install -r scripts/requirements.txt
          else
            echo "scripts/requirements.txt not found; skipping scripts requirements."
          fi

          if [ -f pyproject.toml ]; then
            python -m pip install -e ".[dev]" || python -m pip install -e .
          fi
      - name: Assemble prompt
        id: prompt
        env:
          BASE_PROMPT: ${{ inputs.prompt_file }}
          APPENDIX: ${{ inputs.appendix }}
        run: |
          set -euo pipefail
          base="${BASE_PROMPT}"
          output="codex-prompt.md"

          if [ -z "$base" ] || [ ! -f "$base" ]; then
            echo "Base prompt file not found: ${base}" >&2
            exit 1
          fi

          # Start with agent instructions if available
          if [ -f ".github/codex/AGENT_INSTRUCTIONS.md" ]; then
            {
              cat ".github/codex/AGENT_INSTRUCTIONS.md"
              echo
              echo "---"
              echo
              echo "# Task Prompt"
              echo
            } > "$output"
            cat "$base" >> "$output"
          else
            cat "$base" > "$output"
          fi

          if [ -n "$APPENDIX" ]; then
            {
              echo
              echo "## Run context"
              printf '%s\n' "$APPENDIX"
            } >> "$output"
          fi

          echo "file=${output}" >> "$GITHUB_OUTPUT"

      - name: Install Codex CLI
        run: |
          set -euo pipefail
          echo "Installing Codex CLI..."
          npm install -g @openai/codex
          codex --version

      - name: Setup Codex auth
        env:
          CODEX_AUTH_JSON: ${{ secrets.CODEX_AUTH_JSON }}
        run: |
          set -euo pipefail
          if [ -z "$CODEX_AUTH_JSON" ]; then
            echo "::error::CODEX_AUTH_JSON secret is not set or empty. Please add it to repository secrets."
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          mkdir -p ~/.codex
          echo "$CODEX_AUTH_JSON" > ~/.codex/auth.json
          chmod 600 ~/.codex/auth.json
          echo "âœ… Codex auth configured from CODEX_AUTH_JSON secret"

      - name: Run Codex
        id: run_codex
        env:
          CODEX_HOME: ${{ runner.temp }}/.codex
        run: |
          set -euo pipefail

          # Copy auth to CODEX_HOME
          mkdir -p "$CODEX_HOME"
          cp ~/.codex/auth.json "$CODEX_HOME/auth.json"
          chmod 600 "$CODEX_HOME/auth.json"

          # Build codex exec command
          PROMPT_FILE="${{ steps.prompt.outputs.file }}"
          OUTPUT_FILE="codex-output.md"
          SANDBOX="${{ inputs.sandbox }}"
          EXTRA_ARGS="${{ inputs.codex_args }}"

          # Default sandbox if not specified
          if [ -z "$SANDBOX" ]; then
            SANDBOX="workspace-write"
          fi

          echo "Running Codex CLI directly with ChatGPT auth..."
          echo "Prompt file: $PROMPT_FILE"
          echo "Sandbox: $SANDBOX"

          # Run codex exec with prompt from file
          codex exec \
            --skip-git-repo-check \
            --sandbox "$SANDBOX" \
            --output-last-message "$OUTPUT_FILE" \
            $EXTRA_ARGS \
            "$(cat "$PROMPT_FILE")" || CODEX_EXIT=$?

          CODEX_EXIT=${CODEX_EXIT:-0}
          echo "exit-code=${CODEX_EXIT}" >> "$GITHUB_OUTPUT"

          if [ $CODEX_EXIT -ne 0 ]; then
            echo "::error::Codex CLI exited with code ${CODEX_EXIT}"
          fi

          echo "Codex completed with exit code ${CODEX_EXIT}. Output written to $OUTPUT_FILE"

          # Set outputs for downstream steps
          if [ -f "$OUTPUT_FILE" ]; then
            # Base64 encode full message to avoid heredoc delimiter issues
            encoded=$(base64 -w 0 "$OUTPUT_FILE")
            echo "final-message=${encoded}" >> "$GITHUB_OUTPUT"

            # Summary (first 500 chars, safe for PR comments)
            summary=$(head -c 500 "$OUTPUT_FILE" | tr '\n' ' ' | sed 's/"/\\"/g')
            echo "final-message-summary=${summary}" >> "$GITHUB_OUTPUT"
          else
            echo "final-message=" >> "$GITHUB_OUTPUT"
            echo "final-message-summary=No output captured" >> "$GITHUB_OUTPUT"
          fi

          # Exit with original code to mark job as failed if Codex failed
          exit $CODEX_EXIT

      - name: Commit and push changes
        id: commit
        env:
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
          PUSH_ALLOWED: ${{ steps.auth_token.outputs.push_allowed }}
          PUSH_TOKEN: ${{ steps.auth_token.outputs.push_token }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Count changed files
          CHANGED_FILES=$(git status --porcelain | wc -l)
          echo "files-changed=${CHANGED_FILES}" >> "$GITHUB_OUTPUT"

          if [ "$CHANGED_FILES" -eq 0 ]; then
            echo "No changes to commit."
            echo "changes-made=false" >> "$GITHUB_OUTPUT"
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "changes-made=true" >> "$GITHUB_OUTPUT"
          echo "::notice::Codex made changes to ${CHANGED_FILES} file(s)"

          commit_message="chore(codex-${MODE}): apply updates"
          if [ -n "$PR_NUMBER" ]; then
            commit_message="${commit_message} (PR #${PR_NUMBER})"
          fi

          if [ "$PUSH_ALLOWED" != "true" ]; then
            echo "::error::GitHub App token missing; refusing to push without app identity to preserve workflow triggers."
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          git add -A
          git commit -m "$commit_message"

          # Capture commit SHA before push
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit-sha=${COMMIT_SHA}" >> "$GITHUB_OUTPUT"

          git push "https://x-access-token:${PUSH_TOKEN}@github.com/${{ github.repository }}" "HEAD:${{ github.ref_name }}"

          echo "::notice::Pushed commit ${COMMIT_SHA} with ${CHANGED_FILES} file(s) changed"

      - name: Upload Codex output
        if: always() && hashFiles('codex-output.md') != ''
        uses: actions/upload-artifact@v4
        with:
          name: codex-output
          path: codex-output.md
