name: Reusable Codex Run

on:
  workflow_call:
    inputs:
      skip:
        description: 'If true, skip execution entirely. Used for conditional calls.'
        required: false
        default: false
        type: boolean
      prompt_file:
        description: 'Path to the prompt file that Codex should read.'
        required: true
        type: string
      mode:
        description: 'Codex mode for logging purposes (keepalive | autofix | verifier).'
        required: false
        default: keepalive
        type: string
      pr_number:
        description: 'Optional pull request number (used for logging or comments by callers).'
        required: false
        default: ''
        type: string
      pr_ref:
        description: 'The branch/ref to checkout and push to (e.g., refs/heads/feature-branch).'
        required: false
        default: ''
        type: string
      max_runtime_minutes:
        description: 'Upper bound for the job runtime in minutes.'
        required: false
        default: 45
        type: number
      sandbox:
        description: 'Sandbox mode to pass through to Codex.'
        required: false
        default: workspace-write
        type: string
      safety_strategy:
        description: 'Safety strategy to pass through to Codex.'
        required: false
        default: drop-sudo
        type: string
      codex_args:
        description: 'Optional Codex CLI arguments (string or JSON array).'
        required: false
        default: ''
        type: string
      appendix:
        description: 'Optional context appended to the prompt passed to Codex.'
        required: false
        default: ''
        type: string
    secrets:
      CODEX_AUTH_JSON:
        description: 'JSON contents of ~/.codex/auth.json for ChatGPT subscription auth'
        required: false
      WORKFLOWS_APP_ID:
        required: false
      WORKFLOWS_APP_PRIVATE_KEY:
        required: false
    outputs:
      final-message:
        description: 'Full Codex output message (base64 encoded)'
        value: ${{ jobs.codex.outputs.final-message }}
      final-message-summary:
        description: 'First 500 chars of Codex output (safe for PR comments)'
        value: ${{ jobs.codex.outputs.final-message-summary }}
      exit-code:
        description: 'Codex CLI exit code (0=success)'
        value: ${{ jobs.codex.outputs.exit-code }}
      changes-made:
        description: 'Whether Codex made file changes (true/false)'
        value: ${{ jobs.codex.outputs.changes-made }}
      commit-sha:
        description: 'SHA of the commit if changes were pushed'
        value: ${{ jobs.codex.outputs.commit-sha }}
      files-changed:
        description: 'Number of files changed by Codex'
        value: ${{ jobs.codex.outputs.files-changed }}
      error-category:
        description: 'Error category if failure occurred (transient/auth/resource/logic/unknown)'
        value: ${{ jobs.codex.outputs.error-category }}
      error-type:
        description: 'Error type if failure occurred (codex/infrastructure/auth/unknown)'
        value: ${{ jobs.codex.outputs.error-type }}
      error-recovery:
        description: 'Suggested recovery action if failure occurred'
        value: ${{ jobs.codex.outputs.error-recovery }}

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  codex:
    name: Codex (${{ inputs.mode }})
    runs-on: ubuntu-latest
    environment: agent-standard
    timeout-minutes: ${{ inputs.max_runtime_minutes }}
    if: ${{ !inputs.skip }}
    outputs:
      final-message: ${{ steps.run_codex.outputs.final-message }}
      final-message-summary: ${{ steps.run_codex.outputs.final-message-summary }}
      exit-code: ${{ steps.run_codex.outputs.exit-code }}
      changes-made: ${{ steps.commit.outputs.changes-made }}
      commit-sha: ${{ steps.commit.outputs.commit-sha }}
      files-changed: ${{ steps.commit.outputs.files-changed }}
      error-category: ${{ steps.classify_failure.outputs.error_category }}
      error-type: ${{ steps.classify_failure.outputs.error_type }}
      error-recovery: ${{ steps.classify_failure.outputs.error_recovery }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Select auth token
        id: auth_token
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token || '' }}
        run: |
          set -euo pipefail
          checkout_token="${APP_TOKEN:-${GITHUB_TOKEN}}"
          push_token="${APP_TOKEN:-}"
          source="app-token"
          push_allowed="true"

          if [ -z "$push_token" ]; then
            source="github-token"
            push_allowed="false"
          fi

          {
            echo "checkout_token=${checkout_token}"
            echo "push_token=${push_token}"
            echo "source=${source}"
            echo "push_allowed=${push_allowed}"
          } >> "$GITHUB_OUTPUT"

          {
            echo "WORKFLOWS_TOKEN=${checkout_token}"
            echo "CODEX_MODE=${{ inputs.mode }}"
            echo "CODEX_PR_NUMBER=${{ inputs.pr_number }}"
          } >> "$GITHUB_ENV"

          printf 'Checkout auth: %s; push permitted with app token: %s.\n' "$source" "$push_allowed"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.pr_ref || github.ref }}
          token: ${{ steps.auth_token.outputs.checkout_token }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements*.txt

      - name: Install Python dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            python -m pip install -r requirements.txt
          else
            echo "requirements.txt not found; skipping base requirements install."
          fi

          if [ -f requirements-dev.txt ]; then
            python -m pip install -r requirements-dev.txt
          else
            echo "requirements-dev.txt not found; skipping dev requirements file."
          fi

          if [ -f tools/requirements.txt ]; then
            python -m pip install -r tools/requirements.txt
          else
            echo "tools/requirements.txt not found; skipping tools requirements."
          fi

          if [ -f scripts/requirements.txt ]; then
            python -m pip install -r scripts/requirements.txt
          else
            echo "scripts/requirements.txt not found; skipping scripts requirements."
          fi

          if [ -f pyproject.toml ]; then
            python -m pip install -e ".[dev]" || python -m pip install -e .
          fi
      - name: Assemble prompt
        id: prompt
        env:
          BASE_PROMPT: ${{ inputs.prompt_file }}
          APPENDIX: ${{ inputs.appendix }}
        run: |
          set -euo pipefail
          base="${BASE_PROMPT}"
          output="codex-prompt.md"

          if [ -z "$base" ] || [ ! -f "$base" ]; then
            echo "Base prompt file not found: ${base}" >&2
            exit 1
          fi

          # Start with agent instructions if available
          if [ -f ".github/codex/AGENT_INSTRUCTIONS.md" ]; then
            {
              cat ".github/codex/AGENT_INSTRUCTIONS.md"
              echo
              echo "---"
              echo
              echo "# Task Prompt"
              echo
            } > "$output"
            cat "$base" >> "$output"
          else
            cat "$base" > "$output"
          fi

          if [ -n "$APPENDIX" ]; then
            {
              echo
              echo "## Run context"
              printf '%s\n' "$APPENDIX"
            } >> "$output"
          fi

          echo "file=${output}" >> "$GITHUB_OUTPUT"

      - name: Install Codex CLI
        run: |
          set -euo pipefail
          echo "Installing Codex CLI..."
          npm install -g @openai/codex
          codex --version

      - name: Setup Codex auth
        id: codex_auth
        env:
          CODEX_AUTH_JSON: ${{ secrets.CODEX_AUTH_JSON }}
        run: |
          set -euo pipefail
          if [ -z "$CODEX_AUTH_JSON" ]; then
            echo "::error::CODEX_AUTH_JSON secret is not set or empty. Please add it to repository secrets."
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          mkdir -p ~/.codex
          echo "$CODEX_AUTH_JSON" > ~/.codex/auth.json
          chmod 600 ~/.codex/auth.json
          echo "‚úÖ Codex auth configured from CODEX_AUTH_JSON secret"

          # Check token expiration
          python3 << 'PYEOF'
          import json, base64, datetime, sys, os

          auth_path = os.path.expanduser("~/.codex/auth.json")
          try:
              with open(auth_path) as f:
                  auth = json.load(f)
              token = auth.get("tokens", {}).get("access_token", "")
              if not token:
                  print("::warning::No access token found in auth.json")
                  sys.exit(0)

              parts = token.split(".")
              if len(parts) != 3:
                  print("::warning::Invalid JWT format in access token")
                  sys.exit(0)

              payload = parts[1] + "=" * (4 - len(parts[1]) % 4)
              data = json.loads(base64.urlsafe_b64decode(payload))
              if "exp" not in data:
                  print("::warning::No 'exp' claim found in access token JWT payload")
                  sys.exit(0)
              exp_time = datetime.datetime.fromtimestamp(data["exp"], tz=datetime.timezone.utc)
              now = datetime.datetime.now(tz=datetime.timezone.utc)
              diff = exp_time - now
              days_left = diff.days
              hours_left = diff.total_seconds() / 3600

              print(f"Token expires: {exp_time.isoformat()}")
              print(f"Days until expiration: {days_left}")

              # Output for GitHub Actions
              with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as gh:
                  gh.write(f"token_expires={exp_time.isoformat()}\n")
                  gh.write(f"days_until_expiry={days_left}\n")

              if days_left < 0:
                  print("::error::CODEX_AUTH_JSON has expired! Run 'codex login --device-auth' and update the secret.")
                  print("::error::See docs/ci/CHATGPT_SUBSCRIPTION_CI.md for instructions.")
                  sys.exit(1)
              elif days_left < 2:
                  print(f"::warning::CODEX_AUTH_JSON expires in {hours_left:.0f} hours! Consider refreshing soon.")
                  print("::warning::Run 'codex login --device-auth' and update the CODEX_AUTH_JSON secret.")
              elif days_left < 5:
                  print(f"::notice::CODEX_AUTH_JSON expires in {days_left} days. Plan to refresh before expiration.")
          except Exception as e:
              print(f"::warning::Could not check token expiration: {e}")
          PYEOF

      - name: Run Codex
        id: run_codex
        env:
          CODEX_HOME: ${{ runner.temp }}/.codex
        run: |
          set -euo pipefail

          # Copy auth to CODEX_HOME
          mkdir -p "$CODEX_HOME"
          cp ~/.codex/auth.json "$CODEX_HOME/auth.json"
          chmod 600 "$CODEX_HOME/auth.json"

          # Build codex exec command
          PROMPT_FILE="${{ steps.prompt.outputs.file }}"
          OUTPUT_FILE="codex-output.md"
          SANDBOX="${{ inputs.sandbox }}"
          EXTRA_ARGS="${{ inputs.codex_args }}"

          # Default sandbox if not specified
          if [ -z "$SANDBOX" ]; then
            SANDBOX="workspace-write"
          fi

          echo "Running Codex CLI directly with ChatGPT auth..."
          echo "Prompt file: $PROMPT_FILE"
          echo "Sandbox: $SANDBOX"

          # Run codex exec with prompt from file
          # Build command array to handle EXTRA_ARGS properly
          CODEX_EXIT=0
          if [ -n "${EXTRA_ARGS:-}" ]; then
            eval "codex exec --skip-git-repo-check --sandbox \"$SANDBOX\" --output-last-message \"$OUTPUT_FILE\" $EXTRA_ARGS \"\$(cat \"\$PROMPT_FILE\")\"" || CODEX_EXIT=$?
          else
            codex exec --skip-git-repo-check --sandbox "$SANDBOX" --output-last-message "$OUTPUT_FILE" "$(cat "$PROMPT_FILE")" || CODEX_EXIT=$?
          fi

          echo "exit-code=${CODEX_EXIT}" >> "$GITHUB_OUTPUT"

          if [ "$CODEX_EXIT" -ne 0 ]; then
            echo "::error::Codex CLI exited with code ${CODEX_EXIT}"
          fi

          echo "Codex completed with exit code ${CODEX_EXIT}. Output written to $OUTPUT_FILE"

          # Set outputs for downstream steps
          if [ -f "$OUTPUT_FILE" ]; then
            # Base64 encode full message to avoid heredoc delimiter issues
            encoded=$(base64 -w 0 "$OUTPUT_FILE")
            echo "final-message=${encoded}" >> "$GITHUB_OUTPUT"

            # Summary (first 500 chars, safe for PR comments)
            summary=$(head -c 500 "$OUTPUT_FILE" | tr '\n' ' ' | sed 's/"/\\"/g')
            echo "final-message-summary=${summary}" >> "$GITHUB_OUTPUT"
          else
            echo "final-message=" >> "$GITHUB_OUTPUT"
            echo "final-message-summary=No output captured" >> "$GITHUB_OUTPUT"
          fi

          # Exit with original code to mark job as failed if Codex failed
          exit "$CODEX_EXIT"

      - name: Commit and push changes
        id: commit
        env:
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
          PR_REF: ${{ inputs.pr_ref }}
          PUSH_ALLOWED: ${{ steps.auth_token.outputs.push_allowed }}
          PUSH_TOKEN: ${{ steps.auth_token.outputs.push_token }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Determine the target branch
          TARGET_REF="${PR_REF:-${{ github.ref_name }}}"
          # Strip refs/heads/ prefix if present
          TARGET_BRANCH="${TARGET_REF#refs/heads/}"
          echo "Target branch: ${TARGET_BRANCH}"

          # Count changed files
          CHANGED_FILES=$(git status --porcelain | wc -l)
          echo "files-changed=${CHANGED_FILES}" >> "$GITHUB_OUTPUT"

          if [ "$CHANGED_FILES" -eq 0 ]; then
            echo "No changes to commit."
            echo "changes-made=false" >> "$GITHUB_OUTPUT"
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "changes-made=true" >> "$GITHUB_OUTPUT"
          echo "::notice::Codex made changes to ${CHANGED_FILES} file(s)"

          commit_message="chore(codex-${MODE}): apply updates"
          if [ -n "$PR_NUMBER" ]; then
            commit_message="${commit_message} (PR #${PR_NUMBER})"
          fi

          if [ "$PUSH_ALLOWED" != "true" ]; then
            echo "::error::GitHub App token missing; refusing to push without app identity to preserve workflow triggers."
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          git add -A
          git commit -m "$commit_message"

          # Capture commit SHA before push
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit-sha=${COMMIT_SHA}" >> "$GITHUB_OUTPUT"

          git push "https://x-access-token:${PUSH_TOKEN}@github.com/${{ github.repository }}" "HEAD:${TARGET_BRANCH}"

          echo "::notice::Pushed commit ${COMMIT_SHA} with ${CHANGED_FILES} file(s) changed"

      - name: Upload Codex output
        if: always() && hashFiles('codex-output.md') != ''
        uses: actions/upload-artifact@v4
        with:
          name: codex-output
          path: codex-output.md

      - name: Classify failure type
        id: classify_failure
        if: always() && steps.run_codex.outputs.exit-code != '0'
        uses: actions/github-script@v7
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const { classifyError, ERROR_CATEGORIES, suggestRecoveryAction } = require('./.github/scripts/error_classifier.js');

            const exitCode = process.env.EXIT_CODE || '';
            const summary = process.env.OUTPUT_SUMMARY || '';
            const mode = process.env.MODE || 'unknown';
            const prNumber = process.env.PR_NUMBER || '';

            // Classify the error based on output and exit code
            const errorInfo = classifyError({
              code: exitCode,
              message: summary,
            });

            // Determine error type (codex vs infrastructure)
            let errorType = 'unknown';
            if (exitCode && exitCode !== '0') {
              if (errorInfo.category === ERROR_CATEGORIES.transient) {
                errorType = 'infrastructure';
              } else if (errorInfo.category === ERROR_CATEGORIES.auth) {
                errorType = 'auth';
              } else {
                errorType = 'codex';
              }
            }

            core.setOutput('error_category', errorInfo.category);
            core.setOutput('error_type', errorType);
            core.setOutput('error_recovery', errorInfo.recovery);
            core.setOutput('is_transient', errorInfo.category === ERROR_CATEGORIES.transient ? 'true' : 'false');

            console.log(`Error Classification:`);
            console.log(`  Category: ${errorInfo.category}`);
            console.log(`  Type: ${errorType}`);
            console.log(`  Recovery: ${errorInfo.recovery}`);

      - name: Write error summary to GITHUB_STEP_SUMMARY
        if: always() && steps.run_codex.outputs.exit-code != '0'
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
        run: |
          set -euo pipefail
          {
            echo "## ‚ùå Codex Run Failed"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            echo "| Mode | ${MODE:-unknown} |"
            echo "| Exit Code | ${EXIT_CODE:-unknown} |"
            echo "| Error Category | ${ERROR_CATEGORY:-unknown} |"
            echo "| Error Type | ${ERROR_TYPE:-unknown} |"
            if [ -n "${PR_NUMBER:-}" ]; then
              echo "| PR | #${PR_NUMBER} |"
            fi
            echo ""
            echo "### üîç Recovery Guidance"
            echo ""
            echo "${ERROR_RECOVERY:-Check logs for more details.}"
            echo ""
            if [ -n "${OUTPUT_SUMMARY:-}" ]; then
              echo "### üìù Output Summary"
              echo ""
              echo '```'
              echo "${OUTPUT_SUMMARY}"
              echo '```'
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create error diagnostics artifact
        if: always() && steps.run_codex.outputs.exit-code != '0'
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          IS_TRANSIENT: ${{ steps.classify_failure.outputs.is_transient }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          mkdir -p error-diagnostics

          # Create JSON diagnostics file
          cat > error-diagnostics/diagnostics.json << JSONEOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "run_id": "${{ github.run_id }}",
            "run_url": "${RUN_URL}",
            "mode": "${MODE:-unknown}",
            "pr_number": "${PR_NUMBER:-}",
            "exit_code": "${EXIT_CODE:-unknown}",
            "error_category": "${ERROR_CATEGORY:-unknown}",
            "error_type": "${ERROR_TYPE:-unknown}",
            "is_transient": ${IS_TRANSIENT:-false},
            "recovery_guidance": "${ERROR_RECOVERY:-unknown}"
          }
          JSONEOF

          # Create human-readable diagnostics
          cat > error-diagnostics/README.md << MDEOF
          # Codex Run Error Diagnostics

          **Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Run URL:** ${RUN_URL}

          ## Error Summary

          | Field | Value |
          |-------|-------|
          | Mode | ${MODE:-unknown} |
          | Exit Code | ${EXIT_CODE:-unknown} |
          | Error Category | ${ERROR_CATEGORY:-unknown} |
          | Error Type | ${ERROR_TYPE:-unknown} |
          | Is Transient | ${IS_TRANSIENT:-false} |

          ## Recovery Guidance

          ${ERROR_RECOVERY:-Check logs for more details.}

          ## Output Summary

          \`\`\`
          ${OUTPUT_SUMMARY:-No output captured}
          \`\`\`
          MDEOF

          # Copy codex output if available
          if [ -f "codex-output.md" ]; then
            cp codex-output.md error-diagnostics/
          fi

          echo "Created error diagnostics in error-diagnostics/"

      - name: Upload error diagnostics
        if: always() && steps.run_codex.outputs.exit-code != '0'
        uses: actions/upload-artifact@v4
        with:
          name: error-diagnostics-${{ inputs.mode }}-${{ github.run_id }}
          path: error-diagnostics/
          retention-days: 30

      - name: Post PR comment on non-transient failure
        if: always() && steps.run_codex.outputs.exit-code != '0' && steps.classify_failure.outputs.is_transient != 'true' && inputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          MODE: ${{ inputs.mode }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || prNumber <= 0) {
              console.log('No valid PR number, skipping comment');
              return;
            }

            const exitCode = process.env.EXIT_CODE || 'unknown';
            const category = process.env.ERROR_CATEGORY || 'unknown';
            const errorType = process.env.ERROR_TYPE || 'unknown';
            const recovery = process.env.ERROR_RECOVERY || 'Check logs for details.';
            const summary = process.env.OUTPUT_SUMMARY || 'No output captured';
            const mode = process.env.MODE || 'unknown';
            const runUrl = process.env.RUN_URL || '';

            const marker = '<!-- codex-failure-notification -->';

            const body = `${marker}
            ## ‚ö†Ô∏è Codex ${mode} run failed

            | Field | Value |
            |-------|-------|
            | Exit Code | \`${exitCode}\` |
            | Error Category | \`${category}\` |
            | Error Type | \`${errorType}\` |
            | Run | [View logs](${runUrl}) |

            ### üîß Suggested Recovery

            ${recovery}

            ### üìù What to do

            1. Check the [workflow logs](${runUrl}) for detailed error output
            2. If this is a configuration issue, update the relevant settings
            3. If the error persists, consider adding the \`needs-human\` label for manual review
            4. Re-run the workflow once the issue is resolved

            <details>
            <summary>Output summary</summary>

            \`\`\`
            ${summary.slice(0, 500)}
            \`\`\`

            </details>
            `.trim().split('\n').map(l => l.trim()).join('\n');

            // Check if we already have a failure comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const existingComment = comments.find(c => c.body && c.body.includes(marker));

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body,
              });
              console.log(`Updated existing failure comment: ${existingComment.html_url}`);
            } else {
              const { data: newComment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body,
              });
              console.log(`Created failure comment: ${newComment.html_url}`);
            }

      - name: Add needs-attention label on non-transient failure
        if: always() && steps.run_codex.outputs.exit-code != '0' && steps.classify_failure.outputs.is_transient != 'true' && inputs.pr_number != ''
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || prNumber <= 0) return;

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['agent:needs-attention'],
              });
              console.log('Added agent:needs-attention label');
            } catch (error) {
              console.log(`Could not add label: ${error.message}`);
            }
