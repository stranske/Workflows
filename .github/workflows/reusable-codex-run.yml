name: Reusable Codex Run

on:
  workflow_call:
    inputs:
      skip:
        description: 'If true, skip execution entirely. Used for conditional calls.'
        required: false
        default: false
        type: boolean
      prompt_file:
        description: 'Path to the prompt file that Codex should read.'
        required: true
        type: string
      mode:
        description: 'Codex mode for logging purposes (keepalive | autofix | verifier).'
        required: false
        default: keepalive
        type: string
      pr_number:
        description: 'Optional pull request number (used for logging or comments by callers).'
        required: false
        default: ''
        type: string
      pr_ref:
        description: 'The branch/ref to checkout and push to (e.g., refs/heads/feature-branch).'
        required: false
        default: ''
        type: string
      max_runtime_minutes:
        description: 'Upper bound for the job runtime in minutes.'
        required: false
        default: 45
        type: number
      sandbox:
        description: 'Sandbox mode to pass through to Codex.'
        required: false
        default: workspace-write
        type: string
      safety_strategy:
        description: 'Safety strategy to pass through to Codex.'
        required: false
        default: drop-sudo
        type: string
      codex_args:
        description: 'Optional Codex CLI arguments (string or JSON array).'
        required: false
        default: ''
        type: string
      appendix:
        description: 'Optional context appended to the prompt passed to Codex.'
        required: false
        default: ''
        type: string
      iteration:
        description: 'Current iteration number (for tracking in completion comments).'
        required: false
        default: ''
        type: string
    secrets:
      CODEX_AUTH_JSON:
        description: 'JSON contents of ~/.codex/auth.json for ChatGPT subscription auth'
        required: false
      WORKFLOWS_APP_ID:
        required: false
      WORKFLOWS_APP_PRIVATE_KEY:
        required: false
    outputs:
      final-message:
        description: 'Full Codex output message (base64 encoded)'
        value: ${{ jobs.codex.outputs.final-message }}
      final-message-summary:
        description: 'First 500 chars of Codex output (safe for PR comments)'
        value: ${{ jobs.codex.outputs.final-message-summary }}
      exit-code:
        description: 'Codex CLI exit code (0=success)'
        value: ${{ jobs.codex.outputs.exit-code }}
      changes-made:
        description: 'Whether Codex made file changes (true/false)'
        value: ${{ jobs.codex.outputs.changes-made }}
      commit-sha:
        description: 'SHA of the commit if changes were pushed'
        value: ${{ jobs.codex.outputs.commit-sha }}
      files-changed:
        description: 'Number of files changed by Codex'
        value: ${{ jobs.codex.outputs.files-changed }}
      error-category:
        description: 'Error category if failure occurred (transient/auth/resource/logic/unknown)'
        value: ${{ jobs.codex.outputs.error-category }}
      error-type:
        description: 'Error type if failure occurred (codex/infrastructure/auth/unknown)'
        value: ${{ jobs.codex.outputs.error-type }}
      error-recovery:
        description: 'Suggested recovery action if failure occurred'
        value: ${{ jobs.codex.outputs.error-recovery }}

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  codex:
    name: Codex (${{ inputs.mode }})
    runs-on: ubuntu-latest
    environment: agent-standard
    timeout-minutes: ${{ inputs.max_runtime_minutes }}
    if: ${{ !inputs.skip }}
    outputs:
      final-message: ${{ steps.run_codex.outputs.final-message }}
      final-message-summary: ${{ steps.run_codex.outputs.final-message-summary }}
      exit-code: ${{ steps.run_codex.outputs.exit-code }}
      changes-made: ${{ steps.commit.outputs.changes-made }}
      commit-sha: ${{ steps.commit.outputs.commit-sha }}
      files-changed: ${{ steps.commit.outputs.files-changed }}
      error-category: ${{ steps.classify_failure.outputs.error_category }}
      error-type: ${{ steps.classify_failure.outputs.error_type }}
      error-recovery: ${{ steps.classify_failure.outputs.error_recovery }}
      # LLM analysis outputs
      llm-analysis-run: ${{ steps.llm_analysis.outputs.llm-analysis-run }}
      llm-completed-tasks: ${{ steps.llm_analysis.outputs.completed-tasks }}
      llm-has-completions: ${{ steps.llm_analysis.outputs.has-completions }}
      llm-provider: ${{ steps.llm_analysis.outputs.provider }}
      llm-confidence: ${{ steps.llm_analysis.outputs.confidence }}
      session-event-count: ${{ steps.analyze_session.outputs.event-count }}
      session-todo-count: ${{ steps.analyze_session.outputs.todo-count }}
    steps:
      - name: Mint GitHub App token (preferred)
        id: app_token
        continue-on-error: true
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.WORKFLOWS_APP_ID }}
          private-key: ${{ secrets.WORKFLOWS_APP_PRIVATE_KEY }}

      - name: Select auth token
        id: auth_token
        env:
          APP_TOKEN: ${{ steps.app_token.outputs.token || '' }}
        run: |
          set -euo pipefail
          checkout_token="${APP_TOKEN:-${GITHUB_TOKEN}}"
          push_token="${APP_TOKEN:-}"
          source="app-token"
          push_allowed="true"

          if [ -z "$push_token" ]; then
            source="github-token"
            push_allowed="false"
          fi

          {
            echo "checkout_token=${checkout_token}"
            echo "push_token=${push_token}"
            echo "source=${source}"
            echo "push_allowed=${push_allowed}"
          } >> "$GITHUB_OUTPUT"

          {
            echo "WORKFLOWS_TOKEN=${checkout_token}"
            echo "CODEX_MODE=${{ inputs.mode }}"
            echo "CODEX_PR_NUMBER=${{ inputs.pr_number }}"
          } >> "$GITHUB_ENV"

          printf 'Checkout auth: %s; push permitted with app token: %s.\n' "$source" "$push_allowed"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.pr_ref || github.ref }}
          token: ${{ steps.auth_token.outputs.checkout_token }}

      # Checkout Workflows repo scripts for post-completion, error handling, and LLM analysis
      # These scripts are in stranske/Workflows but need to be available when
      # this reusable workflow runs in consumer repos
      # Note: Uses github.job_workflow_sha to get the same ref as the calling workflow
      - name: Checkout Workflows scripts
        uses: actions/checkout@v4
        with:
          repository: stranske/Workflows
          ref: ${{ github.job_workflow_sha }}
          sparse-checkout: |
            .github/scripts
            scripts
            tools
          sparse-checkout-cone-mode: false
          path: .workflows-lib
          token: ${{ steps.auth_token.outputs.checkout_token }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: pip
          cache-dependency-path: |
            pyproject.toml
            requirements*.txt

      - name: Install Python dependencies
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            python -m pip install -r requirements.txt
          else
            echo "requirements.txt not found; skipping base requirements install."
          fi

          if [ -f requirements-dev.txt ]; then
            python -m pip install -r requirements-dev.txt
          else
            echo "requirements-dev.txt not found; skipping dev requirements file."
          fi

          if [ -f tools/requirements.txt ]; then
            python -m pip install -r tools/requirements.txt
          else
            echo "tools/requirements.txt not found; skipping tools requirements."
          fi

          if [ -f scripts/requirements.txt ]; then
            python -m pip install -r scripts/requirements.txt
          else
            echo "scripts/requirements.txt not found; skipping scripts requirements."
          fi

          if [ -f pyproject.toml ]; then
            python -m pip install -e ".[dev]" || python -m pip install -e .
          fi

      - name: Install Workflows repo LLM dependencies
        run: |
          # Install LLM dependencies from Workflows repo for session analysis
          if [ -f .workflows-lib/tools/requirements.txt ]; then
            echo "Installing LLM analysis dependencies..."
            python -m pip install -r .workflows-lib/tools/requirements.txt || {
              echo "::notice::LLM dependencies not installed, will fall back to regex analysis"
            }
          fi

      - name: Validate prompt template integrity
        id: guard
        env:
          BASE_PROMPT: ${{ inputs.prompt_file }}
        run: |
          set -euo pipefail
          if [ -f ".github/scripts/prompt_integrity_guard.js" ]; then
            echo "Checking prompt template for embedded task content..."
            node .github/scripts/prompt_integrity_guard.js "${BASE_PROMPT}" || {
              echo "::error::Prompt template integrity check failed. See output above."
              echo "::error::The base prompt contains embedded task content that should be removed."
              exit 1
            }
          else
            echo "Guard script not found, skipping integrity check"
          fi

      - name: Assemble prompt
        id: prompt
        env:
          BASE_PROMPT: ${{ inputs.prompt_file }}
          APPENDIX: ${{ inputs.appendix }}
          PR_NUMBER: ${{ inputs.pr_number }}
        run: |
          set -euo pipefail
          base="${BASE_PROMPT}"
          # Use PR-specific filename to avoid merge conflicts when multiple PRs run concurrently
          if [ -n "${PR_NUMBER}" ]; then
            output="codex-prompt-${PR_NUMBER}.md"
          else
            output="codex-prompt.md"
          fi

          if [ -z "$base" ] || [ ! -f "$base" ]; then
            echo "Base prompt file not found: ${base}" >&2
            exit 1
          fi

          # Start with agent instructions if available
          if [ -f ".github/codex/AGENT_INSTRUCTIONS.md" ]; then
            {
              cat ".github/codex/AGENT_INSTRUCTIONS.md"
              echo
              echo "---"
              echo
              echo "## Task Prompt"
              echo
            } > "$output"
            cat "$base" >> "$output"
          else
            cat "$base" > "$output"
          fi

          if [ -n "$APPENDIX" ]; then
            {
              echo
              echo "## Run context"
              printf '%s\n' "$APPENDIX"
            } >> "$output"
          fi

          echo "file=${output}" >> "$GITHUB_OUTPUT"

      - name: Install Codex CLI
        run: |
          set -euo pipefail
          echo "Installing Codex CLI..."
          npm install -g @openai/codex
          codex --version

      - name: Setup Codex auth
        id: codex_auth
        env:
          CODEX_AUTH_JSON: ${{ secrets.CODEX_AUTH_JSON }}
        run: |
          set -euo pipefail
          if [ -z "$CODEX_AUTH_JSON" ]; then
            echo "::error::CODEX_AUTH_JSON secret is not set or empty. Please add it to repository secrets."
            echo "Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            exit 1
          fi
          mkdir -p ~/.codex
          echo "$CODEX_AUTH_JSON" > ~/.codex/auth.json
          chmod 600 ~/.codex/auth.json
          echo "‚úÖ Codex auth configured from CODEX_AUTH_JSON secret"

          # Check token expiration
          python3 << 'PYEOF'
          import json, base64, datetime, sys, os

          auth_path = os.path.expanduser("~/.codex/auth.json")
          try:
              with open(auth_path) as f:
                  auth = json.load(f)
              token = auth.get("tokens", {}).get("access_token", "")
              if not token:
                  print("::warning::No access token found in auth.json")
                  sys.exit(0)

              parts = token.split(".")
              if len(parts) != 3:
                  print("::warning::Invalid JWT format in access token")
                  sys.exit(0)

              payload = parts[1] + "=" * (4 - len(parts[1]) % 4)
              data = json.loads(base64.urlsafe_b64decode(payload))
              if "exp" not in data:
                  print("::warning::No 'exp' claim found in access token JWT payload")
                  sys.exit(0)
              exp_time = datetime.datetime.fromtimestamp(data["exp"], tz=datetime.timezone.utc)
              now = datetime.datetime.now(tz=datetime.timezone.utc)
              diff = exp_time - now
              days_left = diff.days
              hours_left = diff.total_seconds() / 3600

              print(f"Token expires: {exp_time.isoformat()}")
              print(f"Days until expiration: {days_left}")

              # Output for GitHub Actions
              with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as gh:
                  gh.write(f"token_expires={exp_time.isoformat()}\n")
                  gh.write(f"days_until_expiry={days_left}\n")

              if days_left < 0:
                  print("::error::CODEX_AUTH_JSON has expired! Run 'codex login --device-auth' and update the secret.")
                  print("::error::See docs/ci/CHATGPT_SUBSCRIPTION_CI.md for instructions.")
                  sys.exit(1)
              elif days_left < 2:
                  print(f"::warning::CODEX_AUTH_JSON expires in {hours_left:.0f} hours! Consider refreshing soon.")
                  print("::warning::Run 'codex login --device-auth' and update the CODEX_AUTH_JSON secret.")
              elif days_left < 5:
                  print(f"::notice::CODEX_AUTH_JSON expires in {days_left} days. Plan to refresh before expiration.")
          except Exception as e:
              print(f"::warning::Could not check token expiration: {e}")
          PYEOF

      - name: Run Codex
        id: run_codex
        env:
          CODEX_HOME: ${{ runner.temp }}/.codex
        run: |
          set -euo pipefail

          # Copy auth to CODEX_HOME
          mkdir -p "$CODEX_HOME"
          cp ~/.codex/auth.json "$CODEX_HOME/auth.json"
          chmod 600 "$CODEX_HOME/auth.json"

          # Build codex exec command
          PROMPT_FILE="${{ steps.prompt.outputs.file }}"
          # Use PR-specific output filename to avoid merge conflicts
          PR_NUM="${{ inputs.pr_number }}"
          if [ -n "${PR_NUM}" ]; then
            OUTPUT_FILE="codex-output-${PR_NUM}.md"
            SESSION_JSONL="codex-session-${PR_NUM}.jsonl"
          else
            OUTPUT_FILE="codex-output.md"
            SESSION_JSONL="codex-session.jsonl"
          fi
          SANDBOX="${{ inputs.sandbox }}"
          EXTRA_ARGS="${{ inputs.codex_args }}"

          # Default sandbox if not specified
          if [ -z "$SANDBOX" ]; then
            SANDBOX="workspace-write"
          fi

          echo "Running Codex CLI directly with ChatGPT auth..."
          echo "Prompt file: $PROMPT_FILE"
          echo "Sandbox: $SANDBOX"

          # Run codex exec with --json to capture rich session data
          # JSONL events stream to stdout, final message still goes to OUTPUT_FILE
          # Build command array to handle EXTRA_ARGS properly
          # NOTE: --mode flag not yet supported by Codex CLI, removed for now
          CODEX_EXIT=0
          if [ -n "${EXTRA_ARGS:-}" ]; then
            eval "codex exec --json --skip-git-repo-check --sandbox \"$SANDBOX\" --output-last-message \"$OUTPUT_FILE\" $EXTRA_ARGS \"\$(cat \"\$PROMPT_FILE\")\"" > "$SESSION_JSONL" 2>&1 || CODEX_EXIT=$?
          else
            codex exec --json --skip-git-repo-check --sandbox "$SANDBOX" --output-last-message "$OUTPUT_FILE" "$(cat "$PROMPT_FILE")" > "$SESSION_JSONL" 2>&1 || CODEX_EXIT=$?
          fi

          echo "exit-code=${CODEX_EXIT}" >> "$GITHUB_OUTPUT"

          if [ "$CODEX_EXIT" -ne 0 ]; then
            echo "::error::Codex CLI exited with code ${CODEX_EXIT}"
          fi

          echo "Codex completed with exit code ${CODEX_EXIT}. Output written to $OUTPUT_FILE"

          # Set outputs for downstream steps
          if [ -f "$OUTPUT_FILE" ]; then
            # Base64 encode full message to avoid heredoc delimiter issues
            encoded=$(base64 -w 0 "$OUTPUT_FILE")
            echo "final-message=${encoded}" >> "$GITHUB_OUTPUT"

            # Summary (first 500 chars, safe for PR comments)
            summary=$(head -c 500 "$OUTPUT_FILE" | tr '\n' ' ' | sed 's/"/\\"/g')
            echo "final-message-summary=${summary}" >> "$GITHUB_OUTPUT"
          else
            echo "final-message=" >> "$GITHUB_OUTPUT"
            echo "final-message-summary=No output captured" >> "$GITHUB_OUTPUT"
          fi

          # Exit with original code to mark job as failed if Codex failed
          exit "$CODEX_EXIT"

      - name: Analyze Codex session
        id: analyze_session
        if: always()
        env:
          PYTHONPATH: ${{ github.workspace }}
          PR_NUM: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          if [ -n "${PR_NUM}" ]; then
            SESSION_JSONL="codex-session-${PR_NUM}.jsonl"
          else
            SESSION_JSONL="codex-session.jsonl"
          fi
          export SESSION_JSONL

          # Check if session file exists and has content
          if [ ! -f "$SESSION_JSONL" ] || [ ! -s "$SESSION_JSONL" ]; then
            echo "No session JSONL found or file is empty"
            echo "session-available=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Session JSONL captured: $(wc -l < "$SESSION_JSONL") lines"
          echo "session-available=true" >> "$GITHUB_OUTPUT"

          # Basic parsing (always available)
          python3 << 'PYEOF'
          import os
          import sys
          sys.path.insert(0, '.')

          session_file = os.environ.get("SESSION_JSONL", "codex-session.jsonl")
          github_output = os.environ.get("GITHUB_OUTPUT", "/dev/null")

          try:
              from tools.codex_jsonl_parser import parse_codex_jsonl_file

              session = parse_codex_jsonl_file(session_file)

              print(f"::notice::Session parsed: {session.raw_event_count} events")
              print(f"::notice::Agent messages: {len(session.agent_messages)}")
              print(f"::notice::Commands: {len(session.commands)} ({len(session.successful_commands)} ok, {len(session.failed_commands)} failed)")
              print(f"::notice::File changes: {len(session.file_changes)}")
              print(f"::notice::Todo items: {len(session.todo_items)}")

              if session.parse_errors:
                  print(f"::warning::Parse errors: {len(session.parse_errors)}")

              # Output key metrics for downstream steps
              with open(github_output, "a") as f:
                  f.write(f"event-count={session.raw_event_count}\n")
                  f.write(f"message-count={len(session.agent_messages)}\n")
                  f.write(f"command-count={len(session.commands)}\n")
                  f.write(f"file-change-count={len(session.file_changes)}\n")
                  f.write(f"todo-count={len(session.todo_items)}\n")
                  f.write(f"completed-todo-count={len(session.completed_todos)}\n")

          except ImportError as e:
              print(f"::notice::Session parser not available: {e}")
          except Exception as e:
              print(f"::warning::Session analysis failed: {e}")
          PYEOF

      - name: Analyze task completion with LLM
        id: llm_analysis
        if: always() && steps.analyze_session.outputs.session-available == 'true' && inputs.pr_number != ''
        env:
          PYTHONPATH: ${{ github.workspace }}/.workflows-lib:${{ github.workspace }}
          PR_NUM: ${{ inputs.pr_number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          SESSION_JSONL="codex-session-${PR_NUM}.jsonl"
          ANALYSIS_FILE="codex-analysis-${PR_NUM}.json"

          # Fetch PR body to extract tasks
          echo "Fetching PR #${PR_NUM} body..."
          PR_BODY=$(gh pr view "${PR_NUM}" --json body --jq '.body' 2>/dev/null || echo "")

          if [ -z "$PR_BODY" ]; then
            echo "::notice::Could not fetch PR body, skipping LLM analysis"
            echo "llm-analysis-run=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Save PR body to temp file
          echo "$PR_BODY" > pr_body.md

          # Run full LLM analysis and save JSON output
          # Scripts are in .workflows-lib from Workflows repo checkout
          echo "Running LLM-powered task completion analysis..."
          python3 .workflows-lib/scripts/analyze_codex_session.py \
            --session-file "$SESSION_JSONL" \
            --pr-body-file pr_body.md \
            --output json > "$ANALYSIS_FILE" 2>&1 || {
              echo "::warning::LLM analysis failed, continuing without it"
              cat "$ANALYSIS_FILE" 2>/dev/null || true  # Show error for debugging
              echo "llm-analysis-run=false" >> "$GITHUB_OUTPUT"
              rm -f "$ANALYSIS_FILE"
              exit 0
            }

          # Also output to GitHub Actions for visibility
          python3 .workflows-lib/scripts/analyze_codex_session.py \
            --session-file "$SESSION_JSONL" \
            --pr-body-file pr_body.md \
            --output github-actions || true

          echo "llm-analysis-run=true" >> "$GITHUB_OUTPUT"
          echo "analysis-file=$ANALYSIS_FILE" >> "$GITHUB_OUTPUT"

          # Extract key fields for downstream use
          if [ -f "$ANALYSIS_FILE" ]; then
            COMPLETED=$(python3 -c "import json; d=json.load(open('$ANALYSIS_FILE')); print(json.dumps(d.get('completed_tasks', [])))")
            PROVIDER=$(python3 -c "import json; d=json.load(open('$ANALYSIS_FILE')); print(d.get('provider', 'unknown'))")
            CONFIDENCE=$(python3 -c "import json; d=json.load(open('$ANALYSIS_FILE')); print(d.get('confidence', 0))")
            echo "completed-tasks=$COMPLETED" >> "$GITHUB_OUTPUT"
            echo "provider=$PROVIDER" >> "$GITHUB_OUTPUT"
            echo "confidence=$CONFIDENCE" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit and push changes
        id: commit
        env:
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
          PR_REF: ${{ inputs.pr_ref }}
          PUSH_ALLOWED: ${{ steps.auth_token.outputs.push_allowed }}
          PUSH_TOKEN: ${{ steps.auth_token.outputs.push_token }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Determine the target branch
          TARGET_REF="${PR_REF:-${{ github.ref_name }}}"
          # Strip refs/heads/ prefix if present
          TARGET_BRANCH="${TARGET_REF#refs/heads/}"
          echo "Target branch: ${TARGET_BRANCH}"

          # Count changed files
          CHANGED_FILES=$(git status --porcelain | wc -l)
          echo "files-changed=${CHANGED_FILES}" >> "$GITHUB_OUTPUT"

          if [ "$CHANGED_FILES" -eq 0 ]; then
            echo "No uncommitted changes."
            # Check if Codex made commits that we need to push
            # This happens when Codex commits during its run (workspace-write mode)
            REMOTE_URL="https://x-access-token:${PUSH_TOKEN}@github.com/${{ github.repository }}"
            git fetch "${REMOTE_URL}" "${TARGET_BRANCH}" 2>/dev/null || true

            UNPUSHED_COMMITS=0
            if git rev-parse "FETCH_HEAD" >/dev/null 2>&1; then
              UNPUSHED_COMMITS=$(git rev-list FETCH_HEAD..HEAD --count 2>/dev/null || echo "0")
            else
              # Remote branch doesn't exist yet - all local commits are unpushed
              UNPUSHED_COMMITS=$(git rev-list HEAD --count 2>/dev/null || echo "0")
            fi

            if [ "$UNPUSHED_COMMITS" -gt 0 ]; then
              echo "Found ${UNPUSHED_COMMITS} unpushed commit(s) from Codex - pushing them."
              COMMIT_SHA=$(git rev-parse HEAD)
              echo "commit-sha=${COMMIT_SHA}" >> "$GITHUB_OUTPUT"
              echo "changes-made=true" >> "$GITHUB_OUTPUT"
              if [ "$PUSH_ALLOWED" != "true" ]; then
                echo "::error::GitHub App token missing; refusing to push without app identity."
                exit 1
              fi
              git push "${REMOTE_URL}" "HEAD:${TARGET_BRANCH}"
              echo "::notice::Pushed ${UNPUSHED_COMMITS} commit(s) from Codex (SHA: ${COMMIT_SHA})"
              exit 0
            fi

            echo "No uncommitted changes and no unpushed commits."
            echo "changes-made=false" >> "$GITHUB_OUTPUT"
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Exclude codex prompt/output files from commits - they cause merge conflicts
          # when multiple PRs run concurrently. These files are workflow-local and their
          # contents are preserved in workflow artifacts and PR comments instead.
          git checkout -- codex-output*.md codex-prompt*.md 2>/dev/null || true

          # Re-count changes after excluding status files
          CHANGED_FILES=$(git status --porcelain | wc -l)
          echo "files-changed=${CHANGED_FILES}" >> "$GITHUB_OUTPUT"

          # Check if only agents/*.md bootstrap files changed
          STATUS_ONLY_CHANGES=$(git status --porcelain | grep -cvE '^\S+\s+agents/.*\.md$' || echo "0")
          if [ "$STATUS_ONLY_CHANGES" -eq 0 ] && [ "$CHANGED_FILES" -gt 0 ]; then
            echo "Only agent bootstrap files changed - skipping commit to reduce noise."
            echo "changes-made=false" >> "$GITHUB_OUTPUT"
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            git checkout -- agents/ 2>/dev/null || true
            exit 0
          fi

          if [ "$CHANGED_FILES" -eq 0 ]; then
            echo "No changes to commit after excluding status files."
            echo "changes-made=false" >> "$GITHUB_OUTPUT"
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "changes-made=true" >> "$GITHUB_OUTPUT"
          echo "::notice::Codex made changes to ${CHANGED_FILES} file(s)"

          commit_message="chore(codex-${MODE}): apply updates"
          if [ -n "$PR_NUMBER" ]; then
            commit_message="${commit_message} (PR #${PR_NUMBER})"
          fi

          if [ "$PUSH_ALLOWED" != "true" ]; then
            echo "::error::GitHub App token missing; refusing to push without app identity to preserve workflow triggers."
            echo "commit-sha=" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          git add -A
          # Double-check exclusion after git add (safety net)
          git reset HEAD -- codex-output*.md codex-prompt*.md 2>/dev/null || true
          git commit -m "$commit_message"

          # Capture commit SHA before push
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit-sha=${COMMIT_SHA}" >> "$GITHUB_OUTPUT"

          # Pull and rebase before push to handle concurrent changes (e.g., Autofix)
          # This prevents push failures when the branch has been updated while Codex ran
          REMOTE_URL="https://x-access-token:${PUSH_TOKEN}@github.com/${{ github.repository }}"
          echo "::group::Sync with remote before push"
          git fetch "${REMOTE_URL}" "${TARGET_BRANCH}" 2>/dev/null || true
          if git rev-parse "FETCH_HEAD" >/dev/null 2>&1; then
            if ! git rebase FETCH_HEAD; then
              echo "::warning::Rebase failed, attempting merge strategy"
              git rebase --abort 2>/dev/null || true
              git pull --no-rebase "${REMOTE_URL}" "${TARGET_BRANCH}" --allow-unrelated-histories || true
            fi
            # Update commit SHA after rebase/merge
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "commit-sha=${COMMIT_SHA}" >> "$GITHUB_OUTPUT"
          fi
          echo "::endgroup::"

          git push "${REMOTE_URL}" "HEAD:${TARGET_BRANCH}"

          echo "::notice::Pushed commit ${COMMIT_SHA} with ${CHANGED_FILES} file(s) changed"

      - name: Upload Codex output
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: codex-output-${{ inputs.pr_number || github.run_id }}
          path: |
            codex-output*.md
            codex-session*.jsonl
            codex-analysis*.json
          if-no-files-found: ignore

      - name: Post completion checkpoint comment
        id: completion_comment
        if: steps.commit.outputs.changes-made == 'true' && inputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          COMMIT_SHA: ${{ steps.commit.outputs.commit-sha }}
          ITERATION: ${{ inputs.iteration || '' }}
        with:
          script: |
            const { postCompletionComment } = require('./.workflows-lib/.github/scripts/post_completion_comment.js');
            const result = await postCompletionComment({
              github, context, core,
              inputs: {
                pr_number: process.env.PR_NUMBER,
                commit_sha: process.env.COMMIT_SHA,
                iteration: process.env.ITERATION,
                prompt_file: 'codex-prompt.md',
              },
            });
            core.setOutput('posted', result.posted ? 'true' : 'false');
            core.setOutput('tasks', String(result.tasks || 0));
            core.setOutput('acceptance', String(result.acceptance || 0));
            if (result.posted) {
              core.info(`Posted completion checkpoint: ${result.tasks} tasks, ${result.acceptance} acceptance criteria`);
            }

      - name: Classify failure type
        id: classify_failure
        if: always() && steps.run_codex.outputs.exit-code != '0'
        uses: actions/github-script@v7
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const { classifyError, ERROR_CATEGORIES, suggestRecoveryAction } = require('./.workflows-lib/.github/scripts/error_classifier.js');

            const exitCode = process.env.EXIT_CODE || '';
            const summary = process.env.OUTPUT_SUMMARY || '';
            const mode = process.env.MODE || 'unknown';
            const prNumber = process.env.PR_NUMBER || '';

            // Classify the error based on output and exit code
            const errorInfo = classifyError({
              code: exitCode,
              message: summary,
            });

            // Determine error type (codex vs infrastructure)
            let errorType = 'unknown';
            if (exitCode && exitCode !== '0') {
              if (errorInfo.category === ERROR_CATEGORIES.transient) {
                errorType = 'infrastructure';
              } else if (errorInfo.category === ERROR_CATEGORIES.auth) {
                errorType = 'auth';
              } else {
                errorType = 'codex';
              }
            }

            core.setOutput('error_category', errorInfo.category);
            core.setOutput('error_type', errorType);
            core.setOutput('error_recovery', errorInfo.recovery);
            core.setOutput('is_transient', errorInfo.category === ERROR_CATEGORIES.transient ? 'true' : 'false');

            console.log(`Error Classification:`);
            console.log(`  Category: ${errorInfo.category}`);
            console.log(`  Type: ${errorType}`);
            console.log(`  Recovery: ${errorInfo.recovery}`);

      - name: Write error summary to GITHUB_STEP_SUMMARY
        if: always() && steps.run_codex.outputs.exit-code != '0'
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
        run: |
          set -euo pipefail
          {
            echo "## ‚ùå Codex Run Failed"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            echo "| Mode | ${MODE:-unknown} |"
            echo "| Exit Code | ${EXIT_CODE:-unknown} |"
            echo "| Error Category | ${ERROR_CATEGORY:-unknown} |"
            echo "| Error Type | ${ERROR_TYPE:-unknown} |"
            if [ -n "${PR_NUMBER:-}" ]; then
              echo "| PR | #${PR_NUMBER} |"
            fi
            echo ""
            echo "### üîç Recovery Guidance"
            echo ""
            echo "${ERROR_RECOVERY:-Check logs for more details.}"
            echo ""
            if [ -n "${OUTPUT_SUMMARY:-}" ]; then
              echo "### üìù Output Summary"
              echo ""
              echo '```'
              echo "${OUTPUT_SUMMARY}"
              echo '```'
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Create error diagnostics artifact
        if: always() && steps.run_codex.outputs.exit-code != '0'
        env:
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          IS_TRANSIENT: ${{ steps.classify_failure.outputs.is_transient }}
          MODE: ${{ inputs.mode }}
          PR_NUMBER: ${{ inputs.pr_number }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          mkdir -p error-diagnostics

          # Create JSON diagnostics file
          cat > error-diagnostics/diagnostics.json << JSONEOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "run_id": "${{ github.run_id }}",
            "run_url": "${RUN_URL}",
            "mode": "${MODE:-unknown}",
            "pr_number": "${PR_NUMBER:-}",
            "exit_code": "${EXIT_CODE:-unknown}",
            "error_category": "${ERROR_CATEGORY:-unknown}",
            "error_type": "${ERROR_TYPE:-unknown}",
            "is_transient": ${IS_TRANSIENT:-false},
            "recovery_guidance": "${ERROR_RECOVERY:-unknown}"
          }
          JSONEOF

          # Create human-readable diagnostics
          cat > error-diagnostics/README.md << MDEOF
          # Codex Run Error Diagnostics

          **Generated:** $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Run URL:** ${RUN_URL}

          ## Error Summary

          | Field | Value |
          |-------|-------|
          | Mode | ${MODE:-unknown} |
          | Exit Code | ${EXIT_CODE:-unknown} |
          | Error Category | ${ERROR_CATEGORY:-unknown} |
          | Error Type | ${ERROR_TYPE:-unknown} |
          | Is Transient | ${IS_TRANSIENT:-false} |

          ## Recovery Guidance

          ${ERROR_RECOVERY:-Check logs for more details.}

          ## Output Summary

          \`\`\`
          ${OUTPUT_SUMMARY:-No output captured}
          \`\`\`
          MDEOF

          # Copy codex output if available
          if [ -f "codex-output.md" ]; then
            cp codex-output.md error-diagnostics/
          fi

          echo "Created error diagnostics in error-diagnostics/"

      - name: Upload error diagnostics
        if: always() && steps.run_codex.outputs.exit-code != '0'
        uses: actions/upload-artifact@v6
        with:
          name: error-diagnostics-${{ inputs.mode }}-${{ github.run_id }}
          path: error-diagnostics/
          retention-days: 30

      - name: Post PR comment on non-transient failure
        if: always() && steps.run_codex.outputs.exit-code != '0' && steps.classify_failure.outputs.is_transient != 'true' && inputs.pr_number != ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
          EXIT_CODE: ${{ steps.run_codex.outputs.exit-code }}
          ERROR_CATEGORY: ${{ steps.classify_failure.outputs.error_category }}
          ERROR_TYPE: ${{ steps.classify_failure.outputs.error_type }}
          ERROR_RECOVERY: ${{ steps.classify_failure.outputs.error_recovery }}
          OUTPUT_SUMMARY: ${{ steps.run_codex.outputs.final-message-summary }}
          MODE: ${{ inputs.mode }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || prNumber <= 0) {
              console.log('No valid PR number, skipping comment');
              return;
            }

            const exitCode = process.env.EXIT_CODE || 'unknown';
            const category = process.env.ERROR_CATEGORY || 'unknown';
            const errorType = process.env.ERROR_TYPE || 'unknown';
            const recovery = process.env.ERROR_RECOVERY || 'Check logs for details.';
            const summary = process.env.OUTPUT_SUMMARY || 'No output captured';
            const mode = process.env.MODE || 'unknown';
            const runUrl = process.env.RUN_URL || '';

            const marker = '<!-- codex-failure-notification -->';

            const body = `${marker}
            ## ‚ö†Ô∏è Codex ${mode} run failed

            | Field | Value |
            |-------|-------|
            | Exit Code | \`${exitCode}\` |
            | Error Category | \`${category}\` |
            | Error Type | \`${errorType}\` |
            | Run | [View logs](${runUrl}) |

            ### üîß Suggested Recovery

            ${recovery}

            ### üìù What to do

            1. Check the [workflow logs](${runUrl}) for detailed error output
            2. If this is a configuration issue, update the relevant settings
            3. If the error persists, consider adding the \`needs-human\` label for manual review
            4. Re-run the workflow once the issue is resolved

            <details>
            <summary>Output summary</summary>

            \`\`\`
            ${summary.slice(0, 500)}
            \`\`\`

            </details>
            `.trim().split('\n').map(l => l.trim()).join('\n');

            // Check if we already have a failure comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const existingComment = comments.find(c => c.body && c.body.includes(marker));

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body,
              });
              console.log(`Updated existing failure comment: ${existingComment.html_url}`);
            } else {
              const { data: newComment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body,
              });
              console.log(`Created failure comment: ${newComment.html_url}`);
            }

      - name: Add needs-attention label on non-transient failure
        if: always() && steps.run_codex.outputs.exit-code != '0' && steps.classify_failure.outputs.is_transient != 'true' && inputs.pr_number != ''
        continue-on-error: true
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ inputs.pr_number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || prNumber <= 0) return;

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['agent:needs-attention'],
              });
              console.log('Added agent:needs-attention label');
            } catch (error) {
              console.log(`Could not add label: ${error.message}`);
            }
