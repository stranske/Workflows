name: Agents 70 Orchestrator

on:
  schedule:
    # Reduced from */20 to */30 to conserve API rate limit (R-3)
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      params_json:
        description: 'JSON payload of orchestrator parameters to merge with defaults.'
        required: false
        default: '{}'
      options_json:
        description: 'Advanced orchestrator options encoded as JSON.'
        required: false
        default: '{}'
      dry_run:
        description: 'Execute orchestrator in dry-run mode (no write operations).'
        required: false
        default: 'false'
      keepalive_enabled:
        description: 'Enable Codex keepalive sweep for this run (set false to pause).'
        required: false
        default: 'true'
      pr_number:
        description: 'Optional pull request number when targeting a specific branch.'
        required: false
  workflow_run:
    workflows:
      - Gate
      - Dummy (fast-pass) gate
    types: [completed]
  repository_dispatch:
    types:
      - agents-orchestrator-ping
    # Expected payload:
    #   event_type: agents-orchestrator-ping
    #   client_payload:
    #     keepalive_enabled: true|false (optional)
    #     dry_run: true|false (optional)
    #     params: { ... }        # forwarded to params_json
    #     options: { ... }       # forwarded to options_json overrides

# Prevent multiple orchestrator runs from overlapping and consuming excessive API quota
concurrency:
  group: agents-70-orchestrator-singleton
  cancel-in-progress: false

jobs:
  rate-limit-check:
    name: Rate limit pre-check
    runs-on: ubuntu-latest
    outputs:
      safe: ${{ steps.check.outputs.safe || 'true' }}
      remaining: ${{ steps.check.outputs.remaining || '-1' }}
      reset_time: ${{ steps.check.outputs.reset_time || '' }}
    steps:
      - name: Checkout API helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Check GitHub API rate limit
        id: check
        uses: actions/github-script@v7
        env:
          # Threshold below which we defer the run
          # Set to 1000 (20% of 5000/hr PAT limit) to leave buffer for other workflows
          RATE_LIMIT_THRESHOLD: '1000'
        with:
          script: |
            const path = require('path');
            const { checkRateLimitStatus } = require(
              path.join(process.env.GITHUB_WORKSPACE, '.github/scripts/api-helpers.js')
            );
            const threshold = parseInt(process.env.RATE_LIMIT_THRESHOLD || '500', 10);

            // Check PAT rate limit (used for authenticated operations)
            const status = await checkRateLimitStatus(github, { threshold, core });

            core.setOutput('safe', status.safe ? 'true' : 'false');
            core.setOutput('remaining', String(status.remaining));
            core.setOutput('reset_time', status.resetTime || '');
            core.setOutput('percent_used', String(status.percentUsed));

            const summary = core.summary;
            summary.addHeading('Rate Limit Status', 3);

            // Display PAT rate limit
            summary.addHeading('Personal Access Token (PAT)', 4);
            if (status.error) {
              summary.addRaw(`⚠️ Could not check rate limit: ${status.error}`).addEOL();
              summary.addRaw('Proceeding with orchestrator run.').addEOL();
            } else {
              const icon = status.safe ? '✅' : '⛔';
              summary.addRaw(`${icon} **${status.remaining}** / ${status.limit} requests remaining (${status.percentUsed}% used)`).addEOL();
              summary.addRaw(`Threshold: ${threshold} | Resets at: ${status.resetTime}`).addEOL();

              if (!status.safe) {
                const waitMinutes = Math.ceil(status.waitTimeMs / 60000);
                summary.addRaw(`**Deferring orchestrator run** — rate limit too low. Try again in ~${waitMinutes} minutes.`).addEOL();
              }
            }

            // Note: Installation token (GITHUB_TOKEN) has separate rate limits
            // shown in workflow logs but not directly queryable via this token
            summary.addHeading('Note', 4);
            summary.addRaw('Installation token (GITHUB_TOKEN) has separate rate limits. ').addEOL();
            summary.addRaw('Check workflow run headers for `x-ratelimit-*` if other jobs fail with rate limit errors.').addEOL();

            await summary.write();

            if (!status.safe) {
              core.notice(`Rate limit low (${status.remaining}/${status.limit}). Deferring this orchestrator run until ${status.resetTime}.`);
            }

  idle-precheck:
    name: Idle precheck
    needs: rate-limit-check
    if: needs.rate-limit-check.outputs.safe == 'true'
    runs-on: ubuntu-latest
    outputs:
      has_work: ${{ steps.precheck.outputs.has_work || 'false' }}
    steps:
      - name: Detect manual dispatch origin
        if: github.event_name == 'repository_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const sender = context.payload?.sender?.login || 'unknown';
            const type = context.payload?.action || context.payload?.event_type || 'agents-orchestrator-ping';
            core.info(`Repository dispatch received from @${sender} (type: ${type}).`);

      - name: Count agent issues
        id: precheck
        uses: actions/github-script@v7
        with:
          script: |
            const summary = core.summary;
            const { owner, repo } = context.repo;
            const started = Date.now();

            const normalise = (value) => String(value ?? '').trim();
            const toBool = (value) => {
              if (typeof value === 'boolean') {
                return value;
              }
              if (typeof value === 'number') {
                return value !== 0;
              }
              const lowered = normalise(value).toLowerCase();
              if (!lowered) {
                return false;
              }
              return ['true', '1', 'yes', 'on'].includes(lowered);
            };

            const parseMaybeJson = (input) => {
              if (!input) {
                return null;
              }
              if (typeof input === 'object') {
                return input;
              }
              if (typeof input === 'string') {
                const trimmed = input.trim();
                if (!trimmed) {
                  return null;
                }
                try {
                  return JSON.parse(trimmed);
                } catch (error) {
                  core.debug?.(`idle-precheck: failed to parse JSON: ${error.message || error}`);
                }
              }
              return null;
            };

            let keepaliveRequested = false;
            let keepaliveTrace = '';
            const keepaliveSources = new Set();

            const markKeepalive = (source, trace) => {
              keepaliveRequested = true;
              if (source) {
                keepaliveSources.add(source);
              }
              if (!keepaliveTrace && typeof trace === 'string' && trace.trim()) {
                keepaliveTrace = trace.trim();
              }
            };

            const eventName = context.eventName;
            if (eventName === 'workflow_dispatch') {
              const inputs = context.payload?.inputs || {};
              if (toBool(inputs.keepalive_enabled ?? '')) {
                markKeepalive('workflow_dispatch.keepalive_enabled');
              }
              const prInput = String(inputs.pr_number ?? '').trim();
              if (prInput) {
                markKeepalive('workflow_dispatch.pr_number', prInput);
              }
              const params = parseMaybeJson(inputs.params_json);
              if (params && toBool(params.enable_keepalive)) {
                markKeepalive('workflow_dispatch.params_json');
              }
              const options = parseMaybeJson(inputs.options_json);
              if (options) {
                const trace = options.keepalive_trace || options.trace;
                if (trace) {
                  markKeepalive('workflow_dispatch.options_json', trace);
                }
              }
            } else if (eventName === 'repository_dispatch') {
              const payload = context.payload?.client_payload || {};
              if (toBool(payload.keepalive_enabled)) {
                markKeepalive('repository_dispatch.keepalive_enabled');
              }
              const params = parseMaybeJson(payload.params_json || payload.params);
              if (params && toBool(params.enable_keepalive)) {
                markKeepalive('repository_dispatch.params');
              }
              const options = parseMaybeJson(payload.options_json || payload.options);
              if (options) {
                const trace = options.keepalive_trace || options.trace;
                if (trace) {
                  markKeepalive('repository_dispatch.options', trace);
                }
              }
            }

            let count = 0;

            await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                per_page: 100,
              },
              (response, done) => {
                for (const issue of response.data || []) {
                  if (issue.pull_request) {
                    continue;
                  }
                  const labels = Array.isArray(issue.labels) ? issue.labels : [];
                  if (
                    labels.some((label) => {
                      const name = typeof label === 'string' ? label : label?.name;
                      return typeof name === 'string' && name.startsWith('agent:');
                    })
                  ) {
                    count += 1;
                    if (count > 0 && !keepaliveRequested) {
                      done();
                      break;
                    }
                  }
                }
                return [];
              }
            );

            const hasWork = keepaliveRequested || count > 0;
            const elapsed = Math.round((Date.now() - started) / 100) / 10;
            core.setOutput('has_work', hasWork ? 'true' : 'false');

            summary.addHeading('Agents orchestrator idle precheck');
            summary.addRaw(`agent:* issues detected: ${count}`);
            summary.addEOL();
            summary.addRaw(`Duration: ${elapsed.toFixed(1)}s`);
            summary.addEOL();
            if (keepaliveRequested) {
              const sources = Array.from(keepaliveSources);
              summary
                .addRaw(`Keepalive override: requested via ${sources.length ? sources.join(', ') : 'inputs'}.`)
                .addEOL();
              if (keepaliveTrace) {
                summary.addRaw(`Keepalive trace: \`${keepaliveTrace}\``).addEOL();
              }
            }
            if (!hasWork) {
              summary.addRaw('Result: idle, skipping orchestrator dispatch.').addEOL();
            }
            await summary.write();

            if (!hasWork) {
              core.info('Idle, skipping orchestrator dispatch.');
            } else if (keepaliveRequested) {
              const traceInfo = keepaliveTrace ? ` (trace ${keepaliveTrace})` : '';
              core.info(`Keepalive request detected${traceInfo}; proceeding regardless of open agent issues.`);
            } else {
              core.info(`Detected ${count} agent-triage issues; proceeding.`);
            }

  token-preflight:
    name: Prepare keepalive write token
    needs:
      - idle-precheck
    if: needs.idle-precheck.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    outputs:
      token_source: ${{ steps.select.outputs.token || '' }}
    steps:
      - name: Select write token
        id: select
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          set -euo pipefail
          if [ -n "${ACTIONS_TOKEN}" ]; then
            printf 'token=%s\n' 'ACTIONS_BOT_PAT' >>"${GITHUB_OUTPUT}"
            exit 0
          fi
          if [ -n "${SERVICE_TOKEN}" ]; then
            printf 'token=%s\n' 'SERVICE_BOT_PAT' >>"${GITHUB_OUTPUT}"
            exit 0
          fi
          echo '::error::Keepalive orchestrator requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT.' >&2
          exit 1
      - name: Probe keepalive token identity
        if: steps.select.outcome == 'success'
        id: probe_token_identity
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select.outputs.token == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { data } = await github.rest.users.getAuthenticated();
            const login = (data?.login || '').trim();
            if (!login) {
              core.setFailed('Unable to determine identity for keepalive write token.');
              return;
            }
            core.setOutput('login', login);

      - name: Enforce keepalive token identity
        if: steps.select.outcome == 'success'
        env:
          TOKEN_SOURCE: ${{ steps.select.outputs.token || 'none' }}
          TOKEN_LOGIN: ${{ steps.probe_token_identity.outputs.login || '' }}
        run: |
          set -euo pipefail
          token="${TOKEN_SOURCE:-none}"
          login="${TOKEN_LOGIN:-}"
          if [ -z "${login}" ]; then
            echo "::error::Keepalive write token identity is unknown." >&2
            exit 1
          fi

          case "${token}" in
            'ACTIONS_BOT_PAT')
              if [ "${login}" != 'stranske' ]; then
                echo "::error::ACTIONS_BOT_PAT must authenticate as stranske; detected ${login}." >&2
                exit 1
              fi
              ;;
            'SERVICE_BOT_PAT')
              if [ "${login}" != 'stranske-automation-bot' ]; then
                echo "::error::SERVICE_BOT_PAT must authenticate as stranske-automation-bot; detected ${login}." >&2
                exit 1
              fi
              ;;
            *)
              echo "::error::Unknown keepalive token source: ${token}." >&2
              exit 1
              ;;
          esac

          printf 'PREPOST: token=%s login=%s\n' "${token}" "${login}" >>"$GITHUB_STEP_SUMMARY"

  resolve-params:
    name: Resolve Parameters
    needs:
      - idle-precheck
      - token-preflight
    if: needs.idle-precheck.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    outputs:
      enable_readiness: ${{ steps.resolve.outputs.enable_readiness }}
      readiness_agents: ${{ steps.resolve.outputs.readiness_agents }}
      readiness_custom_logins: ${{ steps.resolve.outputs.readiness_custom_logins }}
      require_all: ${{ steps.resolve.outputs.require_all }}
      enable_preflight: ${{ steps.resolve.outputs.enable_preflight }}
      codex_user: ${{ steps.resolve.outputs.codex_user }}
      codex_command_phrase: ${{ steps.resolve.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ steps.resolve.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ steps.resolve.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ steps.resolve.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ steps.resolve.outputs.enable_verify_issue }}
      verify_issue_number: ${{ steps.resolve.outputs.verify_issue_number }}
      enable_watchdog: ${{ steps.resolve.outputs.enable_watchdog }}
      enable_keepalive: ${{ steps.resolve.outputs.enable_keepalive }}
      keepalive_pause_label: ${{ steps.resolve.outputs.keepalive_pause_label }}
      keepalive_max_retries: ${{ steps.resolve.outputs.keepalive_max_retries }}
      enable_bootstrap: ${{ steps.resolve.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ steps.resolve.outputs.bootstrap_issues_label }}
      draft_pr: ${{ steps.resolve.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ steps.resolve.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ steps.resolve.outputs.dry_run }}
      options_json: ${{ steps.resolve.outputs.options_json }}
      dispatcher_force_issue: ${{ steps.resolve.outputs.dispatcher_force_issue }}
      worker_max_parallel: ${{ steps.resolve.outputs.worker_max_parallel }}
      conveyor_max_merges: ${{ steps.resolve.outputs.conveyor_max_merges }}
      keepalive_trace: ${{ steps.resolve.outputs.keepalive_trace }}
      keepalive_round: ${{ steps.resolve.outputs.keepalive_round }}
      keepalive_pr: ${{ steps.resolve.outputs.keepalive_pr }}
    steps:
      - name: Confirm default-branch execution context
        uses: actions/github-script@v7
        with:
          script: |
            const ref = context.ref || '';
            const defaultBranch = context.payload?.repository?.default_branch || 'main';
            const expectedRef = `refs/heads/${defaultBranch}`;
            core.info(`Workflow ref: ${ref}`);
            core.info(`Repository default branch: ${defaultBranch}`);
            if (context.eventName === 'schedule' && ref && ref !== expectedRef) {
              core.setFailed(`Scheduled orchestrator runs must execute from ${expectedRef}, but received ${ref}.`);
            }
      - name: Bootstrap checkout resolver
        uses: actions/checkout@v4
        with:
          path: helpers
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Resolve workflow_run checkout source
        id: checkout_source
        uses: actions/github-script@v7
        with:
          script: |
            const { resolveCheckoutSource } = require('./helpers/.github/scripts/checkout_source.js');
            const fallbackRepo = process.env.GITHUB_REPOSITORY || '';
            const fallbackRef = context.sha || process.env.GITHUB_SHA || '';
            const { repository, ref, warnings } = resolveCheckoutSource({
              core,
              context,
              fallbackRepo,
              fallbackRef,
            });

            core.setOutput('repository', repository);
            core.setOutput('ref', ref);
            warnings.forEach((warning) => core.warning(warning));
      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.checkout_source.outputs.repository || github.repository }}
          ref: ${{ steps.checkout_source.outputs.ref || github.sha }}
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 2
      - name: Resolve dispatch parameters
        id: resolve
        uses: actions/github-script@v7
        env:
          PARAMS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.params_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.params && toJson(github.event.client_payload.params) ||
                github.event.client_payload && github.event.client_payload.params_json ||
                ''
              ) ||
              '{}'
            }}
          WORKFLOW_DRY_RUN: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.dry_run || ''
              ) ||
              ''
            }}
          WORKFLOW_OPTIONS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.options_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.options && toJson(github.event.client_payload.options) ||
                github.event.client_payload && github.event.client_payload.options_json ||
                ''
              ) ||
              ''
            }}
          WORKFLOW_KEEPALIVE_ENABLED: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.keepalive_enabled ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.keepalive_enabled || ''
              ) ||
              ''
            }}
          WORKFLOW_KEEPALIVE_PR: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.pr_number ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && (
                  github.event.client_payload.pr ||
                  github.event.client_payload.pr_number ||
                  github.event.client_payload.issue ||
                  ''
                )
              ) ||
              ''
            }}
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { resolveOrchestratorParams } = require('./.github/scripts/agents_orchestrator_resolve.js');
            await resolveOrchestratorParams({ github, context, core, env: process.env });

      - name: Debug keepalive toggles
        if: always()
        run: |
          echo "::notice::enable_keepalive=${{ steps.resolve.outputs.enable_keepalive }}"
          echo "::notice::keepalive_requested=${{ steps.resolve.outputs.keepalive_requested }}"
          echo "::notice::keepalive_paused_label=${{ steps.resolve.outputs.keepalive_paused_label }}"

  keepalive-guard:
    name: Evaluate keepalive gate
    needs: resolve-params
    if: needs.resolve-params.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.guard.outputs.proceed || 'true' }}
      reason: ${{ steps.guard.outputs.reason || '' }}
      agent_alias: ${{ steps.guard.outputs.agent_alias || '' }}
      run_cap: ${{ steps.guard.outputs.run_cap || '' }}
      active_runs: ${{ steps.guard.outputs.active_runs || '' }}
      active_runs_inflight: ${{ steps.guard.outputs.active_runs_inflight || '' }}
      active_runs_recent: ${{ steps.guard.outputs.active_runs_recent || '' }}
      active_runs_recent_window: ${{ steps.guard.outputs.active_runs_recent_window || '' }}
      has_sync_label: ${{ steps.guard.outputs.has_sync_label || 'false' }}
    steps:
      - name: Checkout guard helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Evaluate keepalive prerequisites
        id: guard
        uses: actions/github-script@v7
        env:
          KEEPALIVE_ENABLED: ${{ needs.resolve-params.outputs.enable_keepalive }}
          KEEPALIVE_TRACE: ${{ needs.resolve-params.outputs.keepalive_trace }}
          KEEPALIVE_ROUND: ${{ needs.resolve-params.outputs.keepalive_round }}
          KEEPALIVE_PR: ${{ needs.resolve-params.outputs.keepalive_pr }}
          KEEPALIVE_MAX_RETRIES: ${{ needs.resolve-params.outputs.keepalive_max_retries || '5' }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            // Do not remove checkout; local helper is required.
            const {
              SKIP_MARKER,
              analyseSkipComments,
              isGateReason,
            } = require('./.github/scripts/keepalive_guard_utils.js');
            const { evaluateKeepaliveGate } = require('./.github/scripts/keepalive_gate.js');
            const normalise = (value) => String(value || '').trim();
            const normaliseNewlines = (value) => normalise(value).replace(/\r\n/g, '\n');
            const toBool = (value) => {
              const norm = normalise(value).toLowerCase();
              return ['true', '1', 'yes', 'on'].includes(norm);
            };

            const toCandidate = (input) => ({
              login: typeof input === 'string' ? input : input?.login || '',
              type: typeof input === 'string' ? '' : input?.type || ''
            });

            const isAssignable = (candidate) => {
              const { login, type } = toCandidate(candidate);
              const raw = normalise(login);
              if (!raw) {
                return false;
              }
              if (/\[bot\]$/i.test(login) || /\[bot\]$/i.test(raw)) {
                return false;
              }
              const loweredType = String(type || '').toLowerCase();
              if (loweredType === 'bot' || loweredType === 'app') {
                return false;
              }
              const lowered = raw.toLowerCase();
              if (lowered.endsWith('-bot')) {
                return false;
              }
              const blocked = new Set([
                'chatgpt-codex-connector',
                'stranske-automation-bot',
                'github-actions',
                'dependabot',
                'copilot'
              ]);
              return !blocked.has(lowered);
            };

            const keepaliveEnabled = toBool(process.env.KEEPALIVE_ENABLED);
            const trace = normalise(process.env.KEEPALIVE_TRACE);
            const round = normalise(process.env.KEEPALIVE_ROUND);
            const prRaw = normalise(process.env.KEEPALIVE_PR);
            const summary = core.summary;
            summary.addHeading('Keepalive gate evaluation');

            const renderLine = (reason) => {
              const labelRound = round || '?';
              const labelTrace = trace || 'unknown';
              const labelReason = reason || 'unspecified';
              return `Keepalive ${labelRound} ${labelTrace} skipped: ${labelReason}`;
            };

            const setOutputs = (proceed, reason) => {
              core.setOutput('proceed', proceed ? 'true' : 'false');
              core.setOutput('reason', reason || '');
            };

            const { owner, repo } = context.repo;

            const appendDetails = (details) => {
              if (!details) {
                return;
              }
              const entries = Array.isArray(details) ? details : [details];
              for (const entry of entries) {
                if (entry) {
                  summary.addRaw(String(entry)).addEOL();
                }
              }
            };

            const finaliseSkip = async (reason, details, options = {}) => {
              const line = renderLine(reason);
              summary.addRaw(line).addEOL();
              appendDetails(details);
              await summary.write();

              setOutputs(false, reason);
            };

            if (!keepaliveEnabled || !trace) {
              setOutputs(true, '');
              summary
                .addRaw('Keepalive gating not required for this run.')
                .addEOL()
                .write();
              return;
            }

            const prNumber = Number(prRaw);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              await finaliseSkip('missing-pr-number');
              return;
            }

            let pr;
            try {
              const response = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pr = response.data;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to load PR #${prNumber}: ${message}`);
              await finaliseSkip('pr-fetch-failed', message ? `Details: ${message}` : null);
              return;
            }

            const preGate = await evaluateKeepaliveGate({
              core,
              github,
              context,
              options: {
                prNumber,
                pullRequest: pr,
                currentRunId: context.runId,
                requireHumanActivation: true,
                requireGateSuccess: true,
              },
            });

            const agentAlias = preGate.primaryAgent || 'codex';
            const runCap = Number.isFinite(preGate.runCap) ? preGate.runCap : '';
            const activeRuns = Number.isFinite(preGate.activeRuns) ? preGate.activeRuns : '';
            const inflightRuns = '';
            const recentRuns = '';
            const recentWindow = '';
            const runCapDetail = (() => {
              const breakdown = preGate.activeBreakdown || {};
              const orchestratorCount = Number(breakdown.orchestrator ?? breakdown['agents-70-orchestrator.yml'] ?? 0);
              const workerCount = Number(breakdown.worker ?? breakdown['agents-72-codex-belt-worker.yml'] ?? 0);
              const normaliseCount = (value) => (Number.isFinite(value) ? value : 0);
              return `run cap detail: orchestrator=${normaliseCount(orchestratorCount)}, worker=${normaliseCount(workerCount)}`;
            })();

            core.setOutput('agent_alias', agentAlias);
            core.setOutput('run_cap', runCap !== '' ? String(runCap) : '');
            core.setOutput('active_runs', activeRuns !== '' ? String(activeRuns) : '');
            core.setOutput('active_runs_inflight', inflightRuns !== '' ? String(inflightRuns) : '');
            core.setOutput('active_runs_recent', recentRuns !== '' ? String(recentRuns) : '');
            core.setOutput('active_runs_recent_window', recentWindow !== '' ? String(recentWindow) : '');
            core.setOutput('has_sync_label', preGate.hasSyncRequiredLabel ? 'true' : 'false');
            core.setOutput('cap', runCap !== '' ? String(runCap) : '');
            core.setOutput('active', activeRuns !== '' ? String(activeRuns) : '');
            core.setOutput('head_sha', preGate.headSha || '');
            core.setOutput('last_green_sha', preGate.lastGreenSha || '');

            if (!preGate.ok) {
              const reason = preGate.reason || 'precondition-failed';
              summary
                .addRaw(renderLine(reason))
                .addEOL()
                .addRaw(`keepalive label: ${preGate.hasKeepaliveLabel ? 'true' : 'false'}`)
                .addEOL()
                .addRaw(`human activation: ${preGate.hasHumanActivation ? 'true' : 'false'}`)
                .addEOL()
                .addRaw(`gate concluded: ${preGate.gateConcluded ? 'true' : 'false'}`)
                .addEOL()
                .addRaw(`sync required label: ${preGate.hasSyncRequiredLabel ? 'true' : 'false'}`)
                .addEOL()
                .addRaw(`run cap: ${preGate.activeRuns}/${preGate.runCap}`)
                .addEOL()
                .addRaw(runCapDetail)
                .addEOL();
              await summary.write();
              setOutputs(false, reason);
              return;
            }

            summary
              .addRaw('keepalive pre-gate satisfied: label, activation, gate, and run-cap checks passed.')
              .addEOL()
              .addRaw(`run cap utilisation: ${preGate.activeRuns}/${preGate.runCap}`)
              .addEOL()
              .addRaw(runCapDetail)
              .addEOL();

            const breakdown = preGate.activeBreakdown || {};
            const orchestratorActive = breakdown.orchestrator ?? breakdown['agents-70-orchestrator.yml'] ?? 0;
            const workerActive = breakdown.worker ?? breakdown['agents-72-codex-belt-worker.yml'] ?? 0;
            core.setOutput('active_breakdown_orchestrator', String(orchestratorActive));
            core.setOutput('active_breakdown_worker', String(workerActive));

            const reasons = [];
            const addReason = (reason) => {
              const value = typeof reason === 'string' ? reason.trim() : '';
              if (!value) {
                return;
              }
              if (!reasons.includes(value)) {
                reasons.push(value);
              }
            };
            let headSha = '';
            if (!pr) {
              addReason('missing-pr');
            } else {
              const labelEntries = Array.isArray(pr.labels) ? pr.labels : [];
              const currentLabels = new Set(
                labelEntries
                  .map((entry) => {
                    if (!entry) {
                      return '';
                    }
                    if (typeof entry === 'string') {
                      return entry.trim().toLowerCase();
                    }
                    const name = typeof entry?.name === 'string' ? entry.name : '';
                    return name.trim().toLowerCase();
                  })
                  .filter(Boolean)
              );

              const requiredLabels = ['agents:keepalive'];
              if (agentAlias) {
                requiredLabels.push(`agent:${agentAlias}`);
              }
              const missingLabels = requiredLabels.filter((label) => !currentLabels.has(label));

              if (missingLabels.length) {
                try {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: prNumber,
                    labels: missingLabels,
                  });
                  summary
                    .addRaw(`Applied keepalive labels to PR #${prNumber}: ${missingLabels.join(', ')}`)
                    .addEOL();
                  for (const label of missingLabels) {
                    currentLabels.add(label);
                  }
                } catch (labelError) {
                  const message = labelError instanceof Error ? labelError.message : String(labelError);
                  summary
                    .addRaw(`Failed to apply keepalive labels to PR #${prNumber}: ${message}`)
                    .addEOL();
                }
              }

              const unresolvedLabels = requiredLabels.filter((label) => !currentLabels.has(label));
              if (unresolvedLabels.length) {
                unresolvedLabels.forEach((label) => addReason(`missing-label:${label}`));
                summary
                  .addRaw(`Missing required keepalive labels: ${unresolvedLabels.join(', ')}`)
                  .addEOL();
              }

              headSha = String(pr.head?.sha || '').trim();
              if ((pr.state || '').toLowerCase() !== 'open') {
                addReason('pr-not-open');
              }
              if (!headSha) {
                addReason('missing-head-sha');
              }
              if (pr.draft) {
                addReason('pr-draft');
              } else {
                if (headSha) {
                  try {
                    const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                      owner,
                      repo,
                      ref: headSha,
                    });
                    const statuses = combined?.statuses || [];
                    const gateStatuses = statuses.filter((status) => {
                      const ctx = (status.context || '').toLowerCase();
                      return ctx === 'gate / gate' || ctx === 'gate' || ctx.endsWith('/ gate');
                    });
                    if (gateStatuses.length) {
                      const statusPreview = gateStatuses
                        .map((status) => `${String(status.context || 'gate').trim()}=${(status.state || 'unknown').toLowerCase()}`)
                        .join(', ');
                      summary.addRaw(`Gate status contexts: ${statusPreview}`).addEOL();
                    } else if (combined?.state) {
                      summary.addRaw(`Gate combined status: ${(combined.state || 'unknown').toLowerCase()}`).addEOL();
                    }
                  } catch (error) {
                    const message = error instanceof Error ? error.message : String(error);
                    core.warning(`Unable to evaluate gate status for ${headSha}: ${message}`);
                  }
                } else {
                  core.warning('Unable to evaluate gate status: pull request head SHA is unavailable.');
                }

                const normalisedHead = headSha ? headSha.toLowerCase() : '';
                const gateWorkflowIds = ['pr-00-gate.yml', 'pr-00-gate.yaml'];
                let gateRunEvaluated = false;

                if (headSha) {
                  for (const workflowId of gateWorkflowIds) {
                    try {
                      const response = await github.rest.actions.listWorkflowRuns({
                        owner,
                        repo,
                        workflow_id: workflowId,
                        branch: pr.head?.ref,
                        per_page: 20,
                        event: 'pull_request',
                      });
                      const runs = response.data?.workflow_runs || [];
                      if (!runs.length) {
                        continue;
                      }

                      const headRun = runs.find((run) => (run.head_sha || '').toLowerCase() === normalisedHead);
                      if (!headRun) {
                        summary
                          .addRaw(`Gate workflow ${workflowId} has ${runs.length} run(s) but none for head ${headSha.slice(0, 7)}.`)
                          .addEOL();
                        continue;
                      }

                      gateRunEvaluated = true;
                      const status = (headRun.status || '').toLowerCase();
                      const conclusion = (headRun.conclusion || '').toLowerCase();
                      summary
                        .addRaw(`Gate workflow ${workflowId} on ${headSha.slice(0, 7)} → status=${status || 'unknown'} conclusion=${conclusion || 'none'}`)
                        .addEOL();

                      if (status !== 'completed') {
                        addReason(`gate-run-status:${status || 'unknown'}`);
                      } else if (conclusion && conclusion !== 'success') {
                        summary.addRaw(`Gate conclusion ${conclusion} detected; continuing keepalive.`).addEOL();
                      }

                      break;
                    } catch (error) {
                      const message = error instanceof Error ? error.message : String(error);
                      summary.addRaw(`Failed to inspect gate workflow ${workflowId}: ${message}`).addEOL();
                    }
                  }
                }

                if (!gateRunEvaluated) {
                  addReason('gate-run-missing');
                }
              }

              const currentAssignees = (pr.assignees || []).map((assignee) => assignee?.login).filter(Boolean);
              const humanAssignees = (pr.assignees || [])
                .filter((assignee) => isAssignable(assignee))
                .map((assignee) => assignee.login)
                .filter(Boolean);

              if (!humanAssignees.length) {
                const candidateLogins = [];
                const author = pr.user;
                if (isAssignable(author)) {
                  candidateLogins.push(author.login);
                }
                for (const reviewer of pr.requested_reviewers || []) {
                  if (isAssignable(reviewer)) {
                    candidateLogins.push(reviewer.login);
                  }
                }

                const uniqueCandidates = [];
                const seen = new Set();
                for (const login of candidateLogins) {
                  const normalised = login.toLowerCase();
                  if (!seen.has(normalised)) {
                    seen.add(normalised);
                    uniqueCandidates.push(login);
                  }
                }

                if (uniqueCandidates.length) {
                  try {
                    await github.rest.issues.addAssignees({
                      owner,
                      repo,
                      issue_number: prNumber,
                      assignees: uniqueCandidates,
                    });
                    summary.addRaw(`Assigned human owners to PR #${prNumber}: ${uniqueCandidates.join(', ')}`).addEOL();
                  } catch (assignmentError) {
                    const message = assignmentError instanceof Error ? assignmentError.message : String(assignmentError);
                    summary.addRaw(`Failed to assign humans to PR #${prNumber}: ${message}`).addEOL();
                  }
                } else {
                  summary.addRaw(`No human assignees available for PR #${prNumber}; continuing without assignment.`).addEOL();
                }
              }
            }

            if (reasons.length) {
              const maxRetries = Math.max(1, Number(process.env.KEEPALIVE_MAX_RETRIES || '5'));
              let skipHistory = { total: 0, highestCount: 0, nonGateCount: 0 };
              try {
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: prNumber,
                  per_page: 100,
                });
                skipHistory = analyseSkipComments(comments || []);
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to scan prior keepalive skip comments: ${message}`);
              }

              const priorSkips = skipHistory.total || 0;
              const priorNonGate = skipHistory.nonGateCount || 0;
              const nextSkipCount = Math.max(1, (skipHistory.highestCount || priorSkips) + 1);
              const nonGateReasons = reasons.filter((reason) => !isGateReason(reason));
              const reasonText = reasons.join(', ');

              if (priorSkips >= maxRetries) {
                await finaliseSkip('too-many-failures', `Previous keepalive attempts: ${priorSkips}`, { skipCount: nextSkipCount });
                return;
              }

              if (nonGateReasons.length === 0) {
                await finaliseSkip(reasonText, undefined, { skipCount: nextSkipCount });
                return;
              }

              if (priorNonGate >= maxRetries) {
                await finaliseSkip('too-many-failures', `Previous non-gate keepalive failures: ${priorNonGate}`, { skipCount: nextSkipCount });
                return;
              }

              if (priorNonGate > 0) {
                await finaliseSkip(`previous-failure:${reasonText}`, `Previous keepalive attempts: ${priorSkips}`, { skipCount: nextSkipCount });
                return;
              }

              await finaliseSkip(reasonText, undefined, { skipCount: nextSkipCount });
              return;
            }

            summary
              .addRaw(`Keepalive ${round || '?'} trace \`${trace}\`: proceed`)
              .addEOL()
              .write();

            setOutputs(true, '');

      - name: Debug keepalive gate outputs
        if: always()
        run: |
          echo "::notice::keepalive_gate_proceed=${{ steps.guard.outputs.proceed }}"
          echo "::notice::keepalive_gate_reason=${{ steps.guard.outputs.reason }}"
          echo "::notice::resolve_enable_keepalive=${{ needs.resolve-params.outputs.enable_keepalive }}"
          echo "::notice::keepalive_run_cap=${{ steps.guard.outputs.run_cap }}"
          echo "::notice::keepalive_active_runs=${{ steps.guard.outputs.active_runs }}"
          echo "::notice::keepalive_active_runs_inflight=${{ steps.guard.outputs.active_runs_inflight }}"
          echo "::notice::keepalive_active_runs_recent=${{ steps.guard.outputs.active_runs_recent }}"
          echo "::notice::keepalive_active_runs_recent_window=${{ steps.guard.outputs.active_runs_recent_window }}"

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr="${PR_NUMBER:-}"
          if [[ -n "${pr}" ]]; then
            pr="#${pr}"
          else
            pr="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE:-0}"
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
            "${ok}" "${reason}" "${pr}" "${agent}" "${cap}" "${active}" "${head}" >>"$GITHUB_STEP_SUMMARY"
        env:
          OK: ${{ steps.guard.outputs.proceed || 'false' }}
          REASON: ${{ steps.guard.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ needs.resolve-params.outputs.keepalive_pr || '' }}
          AGENT_ALIAS: ${{ steps.guard.outputs.agent_alias || '' }}
          CAP: ${{ steps.guard.outputs.cap || steps.guard.outputs.run_cap || '2' }}
          ACTIVE: ${{ steps.guard.outputs.active || steps.guard.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.guard.outputs.head_sha || '' }}


  keepalive-cap:
    name: Enforce keepalive run cap
    needs:
      - resolve-params
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false'
    runs-on: ubuntu-latest
    outputs:
      ok: ${{ steps.cap.outputs.ok || 'false' }}
      reason: ${{ steps.cap.outputs.reason || '' }}
      active: ${{ steps.cap.outputs.active || '' }}
      cap: ${{ steps.cap.outputs.cap || '' }}
    steps:
      - name: Checkout run cap helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Evaluate orchestrator run cap
        id: cap
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.resolve-params.outputs.keepalive_pr || '' }}
          ENABLE_KEEPALIVE: ${{ needs.resolve-params.outputs.enable_keepalive || 'false' }}
          FALLBACK_WORKER_MAX: ${{ needs.resolve-params.outputs.worker_max_parallel || '1' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateRunCapForPr } = require('./.github/scripts/keepalive_gate.js');

            const normalise = (value) => String(value || '').trim();
            const enableKeepalive = normalise(process.env.ENABLE_KEEPALIVE).toLowerCase() === 'true';
            const fallbackMaxRaw = normalise(process.env.FALLBACK_WORKER_MAX || '1');
            const fallbackMax = (() => {
              const parsed = Number.parseInt(fallbackMaxRaw, 10);
              if (!Number.isFinite(parsed) || parsed <= 0) {
                return 1;
              }
              return Math.max(1, Math.min(parsed, 5));
            })();

            if (!enableKeepalive) {
              core.setOutput('ok', 'true');
              core.setOutput('reason', 'keepalive-disabled');
              core.setOutput('cap', String(fallbackMax));
              core.setOutput('active', '0');
              return;
            }

            const prValue = Number.parseInt(normalise(process.env.PR_NUMBER), 10);

            if (!Number.isFinite(prValue) || prValue <= 0) {
              core.setOutput('ok', 'false');
              core.setOutput('reason', 'missing-pr-number');
              core.setOutput('cap', '');
              core.setOutput('active', '');
              return;
            }

            const { owner, repo } = context.repo;
            const currentRunId = context.runId;
            const result = await evaluateRunCapForPr({
              core,
              github,
              owner,
              repo,
              prNumber: prValue,
              includeWorker: false,
              currentRunId,
            });

            const bool = (value) => (value ? 'true' : 'false');
            let capValue = Number(result.runCap);
            if (!Number.isFinite(capValue) || capValue <= 0) {
              capValue = 2;
            } else {
              capValue = Math.max(1, Math.min(capValue, 5));
            }
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('cap', String(capValue));
            core.setOutput('active', String(result.activeRuns ?? ''));

      - name: Summarise run cap decision
        if: steps.cap.outputs.ok == 'false'
        run: |
          set -euo pipefail
          reason="${REASON:-run-cap-reached}"
          pr="${PR_NUMBER:-?}"
          cap="${CAP:-?}"
          active="${ACTIVE:-0}"
          printf 'CAP: ok=false reason=%s pr=#%s cap=%s active=%s\n' \
            "${reason}" "${pr}" "${cap}" "${active}" >>"$GITHUB_STEP_SUMMARY"
        env:
          REASON: ${{ steps.cap.outputs.reason || 'run-cap-reached' }}
          PR_NUMBER: ${{ needs.resolve-params.outputs.keepalive_pr || '' }}
          CAP: ${{ steps.cap.outputs.cap || '' }}
          ACTIVE: ${{ steps.cap.outputs.active || '' }}


  resolve-orchestrator-context:
    name: Resolve orchestrator context
    needs:
      - resolve-params
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number || '' }}
      agent_alias: ${{ steps.resolve.outputs.agent_alias || '' }}
    steps:
      - name: Resolve PR number and agent alias
        id: resolve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const ev = context.payload || {};

            const parseMaybeJson = (value) => {
              if (!value) {
                return null;
              }
              if (typeof value === 'object') {
                return value;
              }
              if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                  return null;
                }
                try {
                  return JSON.parse(trimmed);
                } catch (error) {
                  core.warning(`resolve-context: failed to parse JSON payload: ${error.message || error}`);
                  return null;
                }
              }
              return null;
            };

            let prNumber =
              ev.pull_request?.number ??
              ev.issue?.number ??
              ev.workflow_run?.pull_requests?.[0]?.number ??
              ev.inputs?.pr_number ??
              ev.client_payload?.pr ??
              ev.client_payload?.pr_number ??
              ev.client_payload?.issue ??
              null;

            const normaliseString = (value) => {
              if (value === null || value === undefined) {
                return '';
              }
              return String(value).trim();
            };

            const inputOptions = parseMaybeJson(ev.inputs?.options_json);
            const payloadOptions = parseMaybeJson(ev.client_payload?.options_json || ev.client_payload?.options);

            const fromPayload =
              normaliseString(ev.client_payload?.agent) ||
              normaliseString(ev.client_payload?.agent_alias) ||
              (payloadOptions && (normaliseString(payloadOptions.agent) || normaliseString(payloadOptions.agent_alias))) ||
              (inputOptions && (normaliseString(inputOptions.agent) || normaliseString(inputOptions.agent_alias))) ||
              null;

            const agentFromLabels = async (value) => {
              if (!value) {
                return null;
              }
              const numeric = Number.parseInt(String(value), 10);
              if (!Number.isFinite(numeric) || numeric <= 0) {
                return null;
              }
              try {
                const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: numeric,
                  per_page: 100,
                });
                const agentLabel = Array.isArray(labels)
                  ? labels.find((entry) => {
                      const labelName = typeof entry === 'string' ? entry : entry?.name;
                      return typeof labelName === 'string' && /^agent:/i.test(labelName);
                    })
                  : null;
                if (!agentLabel) {
                  return null;
                }
                const value = typeof agentLabel === 'string' ? agentLabel : agentLabel?.name;
                if (typeof value !== 'string') {
                  return null;
                }
                const stripped = value.replace(/^agent:/i, '').trim();
                return stripped || null;
              } catch (error) {
                core.warning(`resolve-context: failed to fetch labels for #${numeric}: ${error.message || error}`);
                return null;
              }
            };

            let agentAlias = fromPayload;
            if (!agentAlias) {
              agentAlias = await agentFromLabels(prNumber);
            }
            agentAlias = normaliseString(agentAlias);
            if (!agentAlias) {
              agentAlias = 'codex';
            }

            const prNumberString = normaliseString(prNumber);
            const resolvedPrNumber = prNumberString || String(context.runId);

            core.setOutput('pr_number', resolvedPrNumber);
            core.setOutput('agent_alias', agentAlias);

            core.info(`Resolved orchestrator context: pr_number=${resolvedPrNumber}, agent_alias=${agentAlias}`);


  keepalive-prep:
    name: Prepare keepalive round
    needs:
      - resolve-params
      - keepalive-guard
      - keepalive-cap
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_keepalive == 'true' &&
      needs.keepalive-cap.outputs.ok == 'true'
    runs-on: ubuntu-latest
    outputs:
      round: ${{ steps.prepare.outputs.round || '' }}
      trace: ${{ steps.prepare.outputs.trace || '' }}
      actions_available: ${{ steps.prepare.outputs.actions_available || 'false' }}
      dispatch_mode: ${{ steps.prepare.outputs.dispatch_mode || '' }}
      scope_tasks_acceptance: ${{ steps.prepare.outputs.scope_tasks_acceptance || '' }}
      scope_block: ${{ steps.prepare.outputs.scope_block || '' }}
      pr_number: ${{ steps.prepare.outputs.pr_number || '' }}
      baseline_head: ${{ steps.snapshot.outputs.head || '' }}
      head_ref: ${{ steps.snapshot.outputs.head_ref || '' }}
      base_ref: ${{ steps.snapshot.outputs.base_ref || '' }}
      agent: ${{ steps.render_instruction_body.outputs.agent || steps.prepare.outputs.agent || '' }}
      body: ${{ steps.render_instruction_body.outputs.body || '' }}
      instruction_body: ${{ steps.extract_instruction_segment.outputs.instruction || '' }}
      instruction_bytes: ${{ steps.extract_instruction_segment.outputs.bytes || '0' }}
      previous_round: ${{ steps.prepare.outputs.previous_round || '' }}
      existing_instruction_comment_id: ${{ steps.prepare.outputs.existing_instruction_comment_id || '' }}
      existing_instruction_comment_url: ${{ steps.prepare.outputs.existing_instruction_comment_url || '' }}
      existing_instruction_round: ${{ steps.prepare.outputs.existing_instruction_round || '' }}
      existing_instruction_trace: ${{ steps.prepare.outputs.existing_instruction_trace || '' }}
      existing_instruction_author: ${{ steps.prepare.outputs.existing_instruction_author || '' }}
      existing_instruction_reaction: ${{ steps.prepare.outputs.existing_instruction_reaction || 'false' }}
      head_repo: ${{ steps.snapshot.outputs.head_repo || '' }}
    steps:
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
            scripts/keepalive_instruction_segment.js
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Prepare keepalive instruction
        id: prepare
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.resolve-params.outputs.keepalive_pr }}
          ROUND_HINT: ${{ needs.resolve-params.outputs.keepalive_round }}
          OPTIONS_JSON: ${{ needs.resolve-params.outputs.options_json }}
          ACTIONS_AVAILABLE: ${{ secrets.ACTIONS_BOT_PAT != '' }}
          SERVICE_AVAILABLE: ${{ secrets.SERVICE_BOT_PAT != '' }}
          AGENT_ALIAS: ${{ needs.keepalive-guard.outputs.agent_alias }}
        with:
          script: |
            const { makeTrace, renderInstruction } = require('./.github/scripts/keepalive_contract.js');

            const normalise = (value) => String(value || '').trim();
            const normaliseNewlines = (value) => normalise(value).replace(/\r\n/g, '\n');
            const prNumberRaw = normalise(process.env.PR_NUMBER);
            const prNumber = Number.parseInt(prNumberRaw, 10);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Keepalive instruction requires a valid pull request number.');
              return;
            }

            const agentAlias = normalise(process.env.AGENT_ALIAS) || 'codex';

            let instruction = '';
            const optionsSource = process.env.OPTIONS_JSON || '{}';
            try {
              const parsed = JSON.parse(optionsSource);
              instruction = parsed.keepalive_instruction || parsed.keepalive_instruction_template || '';
            } catch (error) {
              core.warning(`Unable to parse keepalive options (${error.message}).`);
            }

            if (!instruction) {
              core.setFailed('Keepalive instruction template missing.');
              return;
            }

            const roundHint = Number.parseInt(normalise(process.env.ROUND_HINT), 10);
            let round = Number.isFinite(roundHint) && roundHint > 0 ? roundHint : 0;

            const { owner, repo } = context.repo;
            const { extractIssueNumberFromPull } = require('./.github/scripts/agents_pr_meta_keepalive.js');

            const defaultSections = {
              scope: '_Keepalive checklist unavailable; will retry next round._',
              tasks: '- [ ] _Rehydrate keepalive checklist content_',
              acceptance: '- [ ] _Rehydrate keepalive checklist content_',
            };

            const formatBlock = ({ scope, tasks, acceptance }) => {
              const ensureChecklist = (value, fallback) => {
                const trimmed = String(value || '').trim();
                if (!trimmed) {
                  return fallback;
                }
                return trimmed
                  .split('\n')
                  .map((line) => {
                    const raw = String(line || '').trim();
                    if (!raw) {
                      return '- [ ]';
                    }
                    if (/^[-*]\s*\[[ xX]\]/.test(raw)) {
                      const mark = raw.match(/^[-*]\s*\[([ xX])\]/)[1];
                      const rest = raw.replace(/^[-*]\s*\[[ xX]\]\s*/, '');
                      const normalisedMark = mark.toLowerCase() === 'x' ? 'x' : ' ';
                      return `- [${normalisedMark}] ${rest.trim()}`;
                    }
                    if (/^[-*]\s+/.test(raw)) {
                      const rest = raw.replace(/^[-*]\s+/, '');
                      return `- [ ] ${rest.trim()}`;
                    }
                    return `- [ ] ${raw}`;
                  })
                  .join('\n');
              };

              const trimmed = (value, fallback) => {
                const text = String(value || '').trim();
                return text || fallback;
              };

              return [
                '#### Scope',
                trimmed(scope, defaultSections.scope),
                '',
                '#### Tasks',
                ensureChecklist(tasks, defaultSections.tasks),
                '',
                '#### Acceptance criteria',
                ensureChecklist(acceptance, defaultSections.acceptance),
              ]
                .map((block) => block.replace(/\s+$/, ''))
                .join('\n');
            };

            const defaultScopeBlock = formatBlock(defaultSections);

            const parseSections = (body) => {
              const content = normaliseNewlines(body);
              if (!content) {
                return null;
              }
              const section = (labels) => {
                const patterns = Array.isArray(labels) ? labels : [labels];
                for (const label of patterns) {
                  const pattern = new RegExp(`####\\s*${label}\\s*([\\s\\S]*?)(?=####\\s*|$)`, 'i');
                  const match = content.match(pattern);
                  if (match && match[1]) {
                    return match[1].trim();
                  }
                }
                return '';
              };

              const sections = {
                scope: section('Scope'),
                tasks: section(['Tasks', 'Task list']),
                acceptance: section(['Acceptance criteria', 'Acceptance Criteria', 'Success criteria', 'Definition of done']),
              };

              const values = Object.values(sections).filter((value) => String(value || '').trim());
              return values.length > 0 ? sections : null;
            };

            const extractKeepaliveChecklist = (body) => {
              const match = normaliseNewlines(body).match(/###\s*Keepalive checklist\s*([\s\S]*)/i);
              if (!match) {
                return '';
              }
              const remainder = match[1] || '';
              const next = remainder.search(/\n###\s+/);
              const segment = next >= 0 ? remainder.slice(0, next) : remainder;
              return segment.trim();
            };

            let scopeBlock = defaultScopeBlock;
            let scopeSource = 'placeholder';

            try {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const prBody = pr?.body || '';
              const keepaliveSection = extractKeepaliveChecklist(prBody);
              const fromKeepalive = parseSections(keepaliveSection);
              if (fromKeepalive) {
                scopeBlock = formatBlock(fromKeepalive);
                scopeSource = 'pr-keepalive';
              } else {
                const issueNumber = extractIssueNumberFromPull(pr);
                if (issueNumber) {
                  try {
                    const issueResponse = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                    const issueSections = parseSections(issueResponse.data?.body || '');
                    if (issueSections) {
                      scopeBlock = formatBlock(issueSections);
                      scopeSource = 'issue-body';
                    }
                  } catch (issueError) {
                    const message = issueError instanceof Error ? issueError.message : String(issueError);
                    core.warning(`Unable to read source issue #${issueNumber} for PR #${prNumber}: ${message}`);
                  }
                }

                if (scopeSource === 'placeholder') {
                  try {
                    const comments = await github.paginate(github.rest.issues.listComments, {
                      owner,
                      repo,
                      issue_number: prNumber,
                      per_page: 100,
                    });
                    const candidates = comments
                      .filter((comment) => /##\s*Automated Status Summary/i.test(comment?.body || ''))
                      .sort((a, b) => new Date(b.updated_at || b.created_at || 0) - new Date(a.updated_at || a.created_at || 0));
                    const latest = candidates[0];
                    const fromComment = latest ? parseSections(latest.body || '') : null;
                    if (fromComment) {
                      scopeBlock = formatBlock(fromComment);
                      scopeSource = 'auto-status-comment';
                    }
                  } catch (commentError) {
                    const message = commentError instanceof Error ? commentError.message : String(commentError);
                    core.warning(`Unable to inspect keepalive status comments: ${message}`);
                  }
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to extract scope/tasks/acceptance for PR #${prNumber}: ${message}`);
              scopeBlock = defaultScopeBlock;
            }

            core.info(`Keepalive scope block sourced from: ${scopeSource}`);
            core.setOutput('scope_block_source', scopeSource);

            core.exportVariable('SCOPE_TASKS_ACCEPTANCE', scopeBlock);
            core.setOutput('scope_block', scopeBlock);

            let highestRound = 0;
            const markerRegex = /<!--\s*codex-keepalive-marker\s*-->/;
            const roundRegex = /<!--\s*keepalive-round\s*:?#?\s*(\d+)\s*-->/;
            const traceRegex = /<!--\s*keepalive-trace\s*:?#?\s*([\s\S]*?)\s*-->/;
            let latestInstruction = null;

            try {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100,
              });
              for (const comment of comments) {
                const body = comment?.body || '';
                if (!markerRegex.test(body)) {
                  continue;
                }
                const roundMatch = body.match(roundRegex);
                const traceMatch = body.match(traceRegex);
                if (!roundMatch || !traceMatch) {
                  continue;
                }
                const parsedRound = Number.parseInt(roundMatch[1], 10);
                if (!Number.isFinite(parsedRound)) {
                  continue;
                }
                if (parsedRound > highestRound) {
                  highestRound = parsedRound;
                }

                const createdAtRaw = comment?.created_at || comment?.updated_at || '';
                const parsedCreatedAt = createdAtRaw ? Date.parse(createdAtRaw) : Number.NaN;
                const createdAt = Number.isFinite(parsedCreatedAt) ? parsedCreatedAt : 0;
                const updatedAtRaw = comment?.updated_at || comment?.created_at || '';
                const parsedUpdatedAt = updatedAtRaw ? Date.parse(updatedAtRaw) : Number.NaN;
                const updatedAt = Number.isFinite(parsedUpdatedAt) ? parsedUpdatedAt : createdAt;
                const candidate = {
                  round: parsedRound,
                  trace: traceMatch[1] ? traceMatch[1].trim() : '',
                  commentId: comment?.id ? String(comment.id) : '',
                  commentUrl: comment?.html_url || '',
                  author: comment?.user?.login || '',
                  createdAt,
                  updatedAt,
                  isEdited: Boolean(comment?.updated_at && comment?.created_at && comment.updated_at !== comment.created_at),
                };

                if (
                  !latestInstruction ||
                  candidate.round > latestInstruction.round ||
                  (candidate.round === latestInstruction.round && (
                    candidate.createdAt > latestInstruction.createdAt ||
                    (candidate.createdAt === latestInstruction.createdAt && candidate.commentId > latestInstruction.commentId)
                  ))
                ) {
                  latestInstruction = candidate;
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to scan existing keepalive comments: ${message}`);
            }

            core.setOutput('previous_round', highestRound ? String(highestRound) : '');

            let existingInstructionReaction = 'false';
            if (latestInstruction?.commentId) {
              const parsedCommentId = Number(latestInstruction.commentId);
              if (Number.isFinite(parsedCommentId)) {
                try {
                  const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                    owner,
                    repo,
                    comment_id: parsedCommentId,
                    per_page: 100,
                  });
                  existingInstructionReaction = reactions.some(
                    (reaction) => (reaction?.content || '').toLowerCase() === 'hooray'
                  )
                    ? 'true'
                    : 'false';
                } catch (reactionError) {
                  const message = reactionError instanceof Error ? reactionError.message : String(reactionError);
                  core.warning(
                    `Unable to retrieve reactions for keepalive instruction comment ${latestInstruction.commentId}: ${message}`
                  );
                }
              } else {
                core.warning(
                  `Skipping reaction inspection; keepalive instruction comment id "${latestInstruction.commentId}" is not numeric.`
                );
              }
            }

            if (latestInstruction) {
              // NOTE: This is a best-effort guard against duplicate postings. The orchestrator lacks
              // a shared lock, so concurrent runs could still interleave between this scan and the
              // eventual comment post. In practice the scheduled cadence keeps collisions low and
              // a matching hooray reaction will prevent ongoing duplication.
              core.setOutput('existing_instruction_comment_id', latestInstruction.commentId || '');
              core.setOutput('existing_instruction_comment_url', latestInstruction.commentUrl || '');
              core.setOutput('existing_instruction_round', String(latestInstruction.round ?? ''));
              core.setOutput('existing_instruction_trace', latestInstruction.trace || '');
              core.setOutput('existing_instruction_author', latestInstruction.author || '');
              core.setOutput('existing_instruction_reaction', existingInstructionReaction || 'false');
            } else {
              core.setOutput('existing_instruction_comment_id', '');
              core.setOutput('existing_instruction_comment_url', '');
              core.setOutput('existing_instruction_round', '');
              core.setOutput('existing_instruction_trace', '');
              core.setOutput('existing_instruction_author', '');
              core.setOutput('existing_instruction_reaction', 'false');
            }

            round = Math.max(round, highestRound) + 1;
            const trace = makeTrace();
            const combinedInstruction = [
              normaliseNewlines(instruction).trim(),
              scopeBlock,
            ]
              .filter(Boolean)
              .join('\n\n');

            const body = renderInstruction({ round, trace, body: combinedInstruction, agent: agentAlias });
            const tokenSource = normalise(process.env.AUTHOR_TOKEN_SOURCE).toUpperCase();
            const actionsAvailable = tokenSource === 'ACTIONS_BOT_PAT';
            const serviceAvailable = tokenSource === 'SERVICE_BOT_PAT';
            const dispatchMode = actionsAvailable
              ? 'actions'
              : serviceAvailable
                ? 'service'
                : 'none';
            const author = normalise(process.env.AUTHOR_LOGIN) || (actionsAvailable ? 'stranske' : 'stranske-automation-bot');

            core.setOutput('round', String(round));
            core.setOutput('trace', trace);
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('actions_available', actionsAvailable ? 'true' : 'false');
            core.setOutput('dispatch_mode', dispatchMode);
            core.setOutput('agent', agentAlias);
            core.setOutput('body', body);
            core.setOutput('scope_tasks_acceptance', instruction);
      - name: Capture keepalive head snapshot
        id: snapshot
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
        with:
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('head', '');
              core.setOutput('head_repo', '');
              core.setOutput('head_ref', '');
              core.setOutput('base_ref', '');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              core.setOutput('head', data?.head?.sha || '');
              core.setOutput('head_repo', data?.head?.repo?.full_name || '');
              core.setOutput('head_ref', data?.head?.ref || '');
              core.setOutput('base_ref', data?.base?.ref || '');
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to capture PR #${prNumber} head snapshot: ${message}`);
              core.setOutput('head', '');
              core.setOutput('head_repo', '');
              core.setOutput('head_ref', '');
              core.setOutput('base_ref', '');
            }

      - name: Persist keepalive head snapshot
        if: steps.snapshot.outputs.head != ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
          TRACE: ${{ steps.prepare.outputs.trace }}
          ROUND: ${{ steps.prepare.outputs.round }}
          HEAD_SHA: ${{ steps.snapshot.outputs.head }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            const trace = normalise(process.env.TRACE);
            const round = normalise(process.env.ROUND);
            const headSha = normalise(process.env.HEAD_SHA);
            if (!Number.isFinite(prNumber) || prNumber <= 0 || !trace || !headSha) {
              core.info('Keepalive state persistence skipped due to missing data.');
              return;
            }

            const { saveKeepaliveState } = require('./.github/scripts/keepalive_state.js');
            await saveKeepaliveState({
              github,
              context,
              prNumber,
              trace,
              round,
              updates: {
                head_sha: headSha,
                head_recorded_at: new Date().toISOString(),
              },
            });

      - name: Render keepalive instruction body
        id: render_instruction_body
        uses: actions/github-script@v7
        env:
          ROUND_DISPLAY: ${{ steps.prepare.outputs.round || '(unknown)' }}
          TRACE_DISPLAY: ${{ steps.prepare.outputs.trace || '(missing)' }}
          PR_NUMBER: ${{ steps.prepare.outputs.pr_number }}
          ROUND_VALUE: ${{ steps.prepare.outputs.round }}
          TRACE_VALUE: ${{ steps.prepare.outputs.trace }}
          COMMENT_BODY: ${{ steps.prepare.outputs.body }}
          SCOPE_TASKS_ACCEPTANCE: ${{ steps.prepare.outputs.scope_tasks_acceptance }}
          SCOPE_BLOCK: ${{ steps.prepare.outputs.scope_block }}
          AUTHOR_DISPLAY: stranske-automation-bot
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prNumber = Number(process.env.PR_NUMBER || 0);

            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Unable to determine pull request number for keepalive instruction.');
              return;
            }

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const agentLabels = Array.isArray(labels)
              ? labels.filter((entry) => typeof entry?.name === 'string' && /^agent:/i.test(entry.name))
              : [];
            const agentAlias = agentLabels.length
              ? agentLabels[0].name.replace(/^agent:/i, '').trim() || 'codex'
              : 'codex';

            const staBlock = (process.env.SCOPE_BLOCK || '').trim()
              || (process.env.SCOPE_TASKS_ACCEPTANCE || '').trim()
              || '*(scope/tasks/acceptance inserted here by orchestrator)*';

            const round = process.env.ROUND_VALUE || process.env.ROUND_DISPLAY || '(unknown)';
            const trace = process.env.TRACE_VALUE || process.env.TRACE_DISPLAY || '(missing)';
            const providedBody = (process.env.COMMENT_BODY || '').trim();

            // Load instruction directive from template file
            const { getKeepaliveInstructionWithMention } = require('./.github/scripts/keepalive_instruction_template.js');
            const instructionDirective = getKeepaliveInstructionWithMention(agentAlias);

            let body = providedBody;
            if (!body) {
              body = [
                `<!-- keepalive-round: ${round} -->`,
                '<!-- codex-keepalive-marker -->',
                `<!-- keepalive-trace: ${trace} -->`,
                instructionDirective,
                '',
                staBlock,
              ].filter(Boolean).join('\n');
            }

            const preview = body.split('\n').slice(0, 6).join('\n') || '(empty)';
            await core.summary
              .addHeading('Keepalive instruction preview', 3)
              .addRaw(`Round: ${round}  Trace: ${trace}  Agent: @${agentAlias}`)
              .addEOL()
              .addCodeBlock(preview, 'markdown')
              .write();

            core.setOutput('agent', agentAlias);
            core.setOutput('body', body);
            core.setOutput('pr_number', String(prNumber));

      - name: Extract instruction payload
        id: extract_instruction_segment
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.render_instruction_body.outputs.body }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const {
              extractInstructionSegment,
              computeInstructionByteLength,
            } = require('./scripts/keepalive_instruction_segment.js');

            const body = process.env.COMMENT_BODY || '';
            const instruction = extractInstructionSegment(body);
            if (!instruction) {
              core.setFailed('Keepalive instruction payload is empty after trimming.');
              return;
            }

            core.setOutput('instruction', instruction);
            core.setOutput('bytes', String(computeInstructionByteLength(instruction)));

  orchestrate:
    name: Dispatch Agents Toolkit
    needs:
      - resolve-params
      - keepalive-guard
      - resolve-orchestrator-context
    if: needs.keepalive-guard.outputs.proceed != 'false'
    concurrency:
      group: ${{ format('keepalive-orchestrator-pr-{0}-agent-{1}-run-{2}', needs.resolve-orchestrator-context.outputs.pr_number || github.run_id, needs.resolve-orchestrator-context.outputs.agent_alias || 'codex', github.run_id) }}
      cancel-in-progress: false
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ needs.resolve-params.outputs.enable_readiness }}
      readiness_agents: ${{ needs.resolve-params.outputs.readiness_agents }}
      readiness_custom_logins: ${{ needs.resolve-params.outputs.readiness_custom_logins }}
      require_all: ${{ needs.resolve-params.outputs.require_all }}
      enable_preflight: ${{ needs.resolve-params.outputs.enable_preflight }}
      codex_user: ${{ needs.resolve-params.outputs.codex_user }}
      codex_command_phrase: ${{ needs.resolve-params.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ needs.resolve-params.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ needs.resolve-params.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ needs.resolve-params.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ needs.resolve-params.outputs.enable_verify_issue }}
      verify_issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      enable_watchdog: ${{ needs.resolve-params.outputs.enable_watchdog }}
      enable_keepalive: ${{ needs.resolve-params.outputs.enable_keepalive }}
      enable_bootstrap: ${{ needs.resolve-params.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ needs.resolve-params.outputs.bootstrap_issues_label }}
      draft_pr: ${{ needs.resolve-params.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run }}
      options_json: ${{ needs.resolve-params.outputs.options_json }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  verify-assignment:
    name: Verify Assignment
    needs:
      - resolve-params
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - resolve-params
      - keepalive-guard
      - verify-assignment
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<-'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi

  belt-dispatch:
    name: Codex Belt Dispatcher
    needs:
      - resolve-params
      - keepalive-guard
    uses: ./.github/workflows/agents-71-codex-belt-dispatcher.yml
    with:
      force_issue: ${{ needs.resolve-params.outputs.dispatcher_force_issue }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-check-existing-pr:
    name: Guard existing Codex PRs
    needs:
      - belt-dispatch
      - keepalive-guard
      - resolve-params
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.belt-dispatch.outputs.issue != '' &&
      needs.belt-dispatch.outputs.branch != ''
    runs-on: ubuntu-latest
    outputs:
      pr_exists: ${{ steps.lookup.outputs.pr_exists || 'false' }}
      pr_number: ${{ steps.lookup.outputs.pr_number || '' }}
      pr_url: ${{ steps.lookup.outputs.pr_url || '' }}
    steps:
      - name: Detect existing PR for issue branch
        id: lookup
        uses: actions/github-script@v7
        env:
          KEEPALIVE_ENABLED: ${{ needs.resolve-params.outputs.enable_keepalive }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = '${{ needs.belt-dispatch.outputs.branch }}';
            const summary = core.summary;
            const keepaliveEnabled = (process.env.KEEPALIVE_ENABLED || '').trim().toLowerCase() === 'true';

            summary.addHeading('Codex belt PR guard');

            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`,
              per_page: 1,
            });

            const existing = Array.isArray(pulls) && pulls.length > 0 ? pulls[0] : null;

            if (!existing) {
              summary.addRaw(`No open PR detected for branch \`${branch}\`.`).write();
              core.setOutput('pr_exists', 'false');
              core.setOutput('pr_number', '');
              core.setOutput('pr_url', '');
              return;
            }

            const prNumber = existing.number ? String(existing.number) : '';
            const prUrl = existing.html_url || (prNumber ? `https://github.com/${owner}/${repo}/pull/${prNumber}` : '');

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'rocket',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add 🎯 reaction to keepalive comment ${commentId}: ${message}`);
            }

            core.info(keepaliveEnabled
              ? 'PR already exists; keepalive override allows worker to continue.'
              : 'PR already exists.');
            core.setOutput('pr_exists', 'true');
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_url', prUrl);

  belt-worker:
    name: Codex Belt Worker
    needs:
      - resolve-params
      - belt-dispatch
      - keepalive-guard
      - keepalive-cap
      - belt-check-existing-pr
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.keepalive-cap.outputs.ok == 'true' &&
      needs.keepalive-cap.outputs.cap != '0' &&
      needs.belt-dispatch.outputs.issue != ''
      && (
        needs.belt-check-existing-pr.outputs.pr_exists != 'true' ||
        needs.resolve-params.outputs.enable_keepalive == 'true'
      )
    uses: ./.github/workflows/agents-72-codex-belt-worker.yml
    with:
      issue: ${{ needs.belt-dispatch.outputs.issue }}
      branch: ${{ needs.belt-dispatch.outputs.branch }}
      base: ${{ needs.belt-dispatch.outputs.base }}
      source: ${{ needs.belt-dispatch.outputs.reason }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true' }}
      max_parallel: ${{ fromJson(needs.keepalive-cap.outputs.cap || '1') }}
      keepalive: ${{ needs.resolve-params.outputs.enable_keepalive == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  dry-run-branch-sync:
    name: Validate branch sync (dry-run)
    needs:
      - resolve-params
      - keepalive-guard
      - keepalive-prep
      - belt-dispatch
      - belt-worker
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_keepalive == 'true' &&
      (needs.resolve-params.outputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true') &&
      needs.keepalive-prep.outputs.trace != '' &&
      needs.keepalive-prep.outputs.pr_number != '' &&
      needs.keepalive-prep.outputs.base_ref != '' &&
      needs.keepalive-prep.outputs.head_ref != '' &&
      needs.keepalive-prep.outputs.baseline_head != ''
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
      pull-requests: read
    outputs:
      run_url: ${{ steps.await.outputs.run_url || '' }}
      run_conclusion: ${{ steps.await.outputs.conclusion || '' }}
      run_id: ${{ steps.await.outputs.run_id || '' }}
      head_updated: ${{ steps.head_check.outputs.updated || 'false' }}
      new_head: ${{ steps.head_check.outputs.new_head || '' }}
      pr_url: ${{ steps.head_check.outputs.pr_url || '' }}
    steps:
      - name: Ensure branch-sync token available
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ]; then
            echo "::error::Branch-sync validation requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch keepalive branch sync
        id: dispatch
        uses: actions/github-script@v7
        env:
          WORKFLOW_ID: agents-keepalive-branch-sync.yml
          TARGET_REF: ${{ github.event.repository.default_branch }}
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          BASE_REF: ${{ needs.keepalive-prep.outputs.base_ref }}
          HEAD_REF: ${{ needs.keepalive-prep.outputs.head_ref }}
          HEAD_SHA: ${{ needs.keepalive-prep.outputs.baseline_head }}
          HEAD_REPO: ${{ needs.keepalive-prep.outputs.head_repo }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          AGENT: ${{ needs.keepalive-prep.outputs.agent }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const workflowId = process.env.WORKFLOW_ID || 'agents-keepalive-branch-sync.yml';
            let ref = (process.env.TARGET_REF || '').trim();
            if (!ref) {
              ref = context.payload?.repository?.default_branch || 'main';
            }
            ref = ref.replace(/^refs\/heads\//, '');

            const requiredKeys = ['PR_NUMBER', 'TRACE', 'BASE_REF', 'HEAD_REF', 'HEAD_SHA'];
            const missing = requiredKeys.filter((key) => !(process.env[key] || '').trim());
            if (missing.length) {
              core.setFailed(`Branch-sync dispatch missing inputs: ${missing.join(', ')}`);
              return;
            }

            const inputs = {
              pr_number: String(process.env.PR_NUMBER || ''),
              trace: String(process.env.TRACE || ''),
              base_ref: String(process.env.BASE_REF || ''),
              head_ref: String(process.env.HEAD_REF || ''),
              head_sha: String(process.env.HEAD_SHA || ''),
              head_repository: String(process.env.HEAD_REPO || ''),
              head_is_fork: '',
              agent: String(process.env.AGENT || ''),
              round: String(process.env.ROUND || ''),
            };

            const baseRepo = `${context.repo.owner}/${context.repo.repo}`.toLowerCase();
            const headRepo = (process.env.HEAD_REPO || '').toLowerCase();
            if (headRepo) {
              inputs.head_is_fork = headRepo !== baseRepo ? 'true' : 'false';
            }

            while (Date.now() < deadline) {
              const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                owner,
                repo,
                comment_id: commentId,
                per_page: 100,
              });
              if (reactions.some((reaction) => (reaction?.content || '').toLowerCase() === 'rocket')) {
                acknowledged = true;
                ackSource = 'reaction';
                break;
              }

              if (Date.now() - lastRunCheck >= runPollInterval) {
                lastRunCheck = Date.now();
                const runAck = await checkWorkflowRuns();
                if (runAck) {
                  acknowledged = true;
                  ackSource = 'pr-meta';
                  break;
                }
              }

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: workflowId,
              ref,
              inputs,
            });

            const now = new Date().toISOString();
            core.setOutput('ref', ref);
            core.setOutput('dispatched_at', now);
            core.setOutput('idempotency_key', inputs.idempotency_key);

      - name: Await branch-sync completion
        id: await
        uses: actions/github-script@v7
        env:
          WORKFLOW_ID: agents-keepalive-branch-sync.yml
          REF: ${{ steps.dispatch.outputs.ref }}
          DISPATCHED_AT: ${{ steps.dispatch.outputs.dispatched_at }}
          TIMEOUT_SECONDS: 600
          POLL_SECONDS: 15
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const workflowId = process.env.WORKFLOW_ID || 'agents-keepalive-branch-sync.yml';
            let ref = (process.env.REF || '').trim();
            if (!ref) {
              ref = context.payload?.repository?.default_branch || 'main';
            }
            const dispatchedAt = Date.parse(process.env.DISPATCHED_AT || new Date().toISOString());
            const timeoutMs = (Number(process.env.TIMEOUT_SECONDS) || 600) * 1000;
            const pollMs = (Number(process.env.POLL_SECONDS) || 15) * 1000;
            const deadline = Date.now() + timeoutMs;

            let runId = 0;
            let run = null;

            while (Date.now() < deadline) {
              if (!runId) {
                const { data } = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflowId,
                  event: 'workflow_dispatch',
                  per_page: 20,
                });

                const candidates = Array.isArray(data.workflow_runs) ? data.workflow_runs : [];
                const candidate = candidates.find((entry) => {
                  const created = Date.parse(entry.created_at || 0);
                  if (!Number.isFinite(created) || created + 1000 < dispatchedAt - 2000) {
                    return false;
                  }
                  const headBranch = (entry.head_branch || '').trim();
                  if (headBranch && headBranch !== ref) {
                    return false;
                  }
                  return true;
                });

                if (candidate) {
                  runId = candidate.id;
                  run = candidate;
                }
              } else {
                const { data } = await github.rest.actions.getWorkflowRun({
                  owner,
                  repo,
                  run_id: runId,
                });
                run = data;
                if (run.status === 'completed') {
                  break;
                }
              }

              if (run && run.status === 'completed') {
                break;
              }

              await new Promise((resolve) => setTimeout(resolve, pollMs));
            }

            if (!run) {
              core.setFailed('Unable to locate branch-sync workflow run.');
              return;
            }

            if (run.status !== 'completed') {
              core.setFailed(`Branch-sync workflow did not complete before timeout (status=${run.status}).`);
              return;
            }

            core.setOutput('run_id', String(run.id || ''));
            core.setOutput('run_url', run.html_url || '');
            core.setOutput('conclusion', run.conclusion || '');
            core.setOutput('status', run.status || '');

            if ((run.conclusion || '').toLowerCase() !== 'success') {
              core.setFailed(`Branch-sync workflow concluded with ${run.conclusion || 'unknown'}.`);
            }

      - name: Check staging PR head
        id: head_check
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const prNumber = Number.parseInt(normalise(process.env.PR_NUMBER), 10);
            const baseline = normalise(process.env.BASELINE_HEAD);

            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('updated', 'false');
              core.setOutput('new_head', '');
              core.setOutput('pr_url', '');
              return;
            }

            const { owner, repo } = context.repo;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const newHead = normalise(pr?.head?.sha);
            core.setOutput('new_head', newHead);
            core.setOutput('updated', newHead && baseline && newHead !== baseline ? 'true' : 'false');
            core.setOutput('pr_url', pr?.html_url || `https://github.com/${owner}/${repo}/pull/${prNumber}`);

      - name: Summarise branch-sync validation
        env:
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          RUN_URL: ${{ steps.await.outputs.run_url }}
          CONCLUSION: ${{ steps.await.outputs.conclusion }}
          PR_URL: ${{ steps.head_check.outputs.pr_url }}
          UPDATED: ${{ steps.head_check.outputs.updated }}
          NEW_HEAD: ${{ steps.head_check.outputs.new_head }}
        run: |
          head_change='unchanged'
          if [ "${UPDATED}" = 'true' ] && [ -n "${NEW_HEAD}" ]; then
            head_change="advanced to ${NEW_HEAD:0:12}"
          fi

          sync_link='(not available)'
          if [ -n "${RUN_URL}" ]; then
            sync_link="[run](${RUN_URL})"
          fi

          pr_link='(n/a)'
          if [ -n "${PR_URL}" ]; then
            pr_link="[link](${PR_URL})"
          fi

          cat <<EOF >>"$GITHUB_STEP_SUMMARY"
          ## Branch-sync validation
          | Round | Trace | Result | Sync run | PR | Head change |
          |---|---|---|---|---|---|
          | ${ROUND:-?} | \`${TRACE:-n/a}\` | ${CONCLUSION:-unknown} | ${sync_link} | ${pr_link} | ${head_change} |
          EOF

  keepalive-post-work:
    name: Keepalive post-work sync
    needs:
      - resolve-params
      - keepalive-guard
      - keepalive-prep
      - belt-dispatch
      - belt-worker
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_keepalive == 'true' &&
      needs.keepalive-prep.outputs.trace != '' &&
      needs.keepalive-prep.outputs.pr_number != '' &&
      needs.belt-dispatch.outputs.issue != '' &&
      needs.belt-dispatch.outputs.branch != '' &&
      needs.belt-worker.result == 'success' &&
      needs.resolve-params.outputs.dry_run != 'true'
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: write
      pull-requests: write
    outputs:
      action: ${{ steps.reconcile.outputs.action || '' }}
      changed: ${{ steps.reconcile.outputs.changed || 'false' }}
      mode: ${{ steps.reconcile.outputs.mode || '' }}
      merged_sha: ${{ steps.reconcile.outputs.merged_sha || '' }}
      success: ${{ steps.reconcile.outputs.success || '' }}
      status: ${{ steps.reconcile.outputs.status || '' }}
      status_head: ${{ steps.reconcile.outputs.status_head || '' }}
      status_base: ${{ steps.reconcile.outputs.status_base || '' }}
      status_mode: ${{ steps.reconcile.outputs.status_mode || '' }}
      link: ${{ steps.reconcile.outputs.link || '-' }}
    steps:
      - name: Ensure keepalive sync token available
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ]; then
            echo "::error::Keepalive sync requires ACTIONS_BOT_PAT." >&2
            exit 1
          fi

      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Reconcile keepalive branch state
        id: reconcile
        uses: actions/github-script@v7
        env:
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          ISSUE_NUMBER: ${{ needs.belt-dispatch.outputs.issue }}
          BASE_BRANCH: ${{ needs.belt-dispatch.outputs.base }}
          PR_BASE_BRANCH: ${{ needs.keepalive-prep.outputs.base_ref }}
          HEAD_BRANCH: ${{ needs.belt-dispatch.outputs.branch }}
          PR_HEAD_BRANCH: ${{ needs.keepalive-prep.outputs.head_ref }}
          HEAD_REPO: ${{ needs.keepalive-prep.outputs.head_repo }}
          PREVIOUS_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head }}
          COMMENT_ID: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_id }}
          COMMENT_URL: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_url }}
          COMMENT_TRACE: ${{ needs.keepalive-prep.outputs.existing_instruction_trace }}
          COMMENT_ROUND: ${{ needs.keepalive-prep.outputs.existing_instruction_round }}
          AGENT_ALIAS: ${{ needs.keepalive-prep.outputs.agent || needs.keepalive-guard.outputs.agent_alias }}
          TTL_SHORT_MS: 90000
          POLL_SHORT_MS: 5000
          TTL_LONG_MS: 240000
          POLL_LONG_MS: 5000
          SYNC_LABEL: agents:sync-required
          DEBUG_LABEL: agents:debug
          DISPATCH_EVENT_TYPE: codex-pr-comment-command
          AUTOMATION_LOGINS: chatgpt-codex-connector,stranske-automation-bot

          MERGE_METHOD: squash
          DELETE_TEMP_BRANCH: 'true'
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const { runKeepalivePostWork } = require('./.github/scripts/keepalive_post_work.js');
            await runKeepalivePostWork({ core, github, context, env: process.env });

  keepalive-instruction:
    name: Post keepalive instruction
    needs:
      - resolve-params
      - keepalive-guard
      - keepalive-cap
      - keepalive-prep
      - keepalive-post-work
      - token-preflight
    if: |
      always() &&
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_keepalive == 'true' &&
      needs.keepalive-cap.outputs.ok == 'true'
    runs-on: ubuntu-latest
    outputs:
      round: ${{ needs.keepalive-prep.outputs.round || '' }}
      trace: ${{ needs.keepalive-prep.outputs.trace || '' }}
      author: ${{ steps.capture_comment.outputs.author || steps.author_token.outputs.author || '' }}
      dispatch_mode: ${{ needs.keepalive-prep.outputs.dispatch_mode || '' }}
      comment_id: ${{ steps.capture_comment.outputs.comment_id || '' }}
      comment_url: ${{ steps.capture_comment.outputs.comment_url || '' }}
      acknowledged: ${{ steps.ack.outputs.acknowledged || 'false' }}
      actions_available: ${{ needs.keepalive-prep.outputs.actions_available || 'false' }}
      pr_number: ${{ needs.keepalive-prep.outputs.pr_number || '' }}
      baseline_head: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
      head_ref: ${{ needs.keepalive-prep.outputs.head_ref || '' }}
      base_ref: ${{ needs.keepalive-prep.outputs.base_ref || '' }}
      agent: ${{ needs.keepalive-prep.outputs.agent || '' }}
      should_post: ${{ steps.gate.outputs.should_post || 'false' }}
      skip_reason: ${{ steps.gate.outputs.skip_reason || '' }}
    steps:
      - name: Evaluate instruction gating
        id: gate
        run: |
          set -euo pipefail
          : "${POST_WORK_RESULT:=}"
          : "${POST_WORK_SUCCESS:=}"
          : "${POST_WORK_CHANGED:=}"
          : "${DRY_RUN:=}"
          : "${EXISTING_ROUND:=}"
          : "${EXISTING_TRACE:=}"
          : "${EXISTING_REACTION:=}"
          : "${EXISTING_COMMENT_ID:=}"
          : "${EXISTING_COMMENT_URL:=}"
          : "${CURRENT_ROUND:=}"
          : "${CURRENT_TRACE:=}"
          result="${POST_WORK_RESULT}";
          success="${POST_WORK_SUCCESS}";
          changed="${POST_WORK_CHANGED}";
          dry_run="${DRY_RUN}";
          existing_round="${EXISTING_ROUND}"
          existing_trace="${EXISTING_TRACE}"
          existing_reaction="${EXISTING_REACTION}"
          existing_comment_id="${EXISTING_COMMENT_ID}"
          existing_comment_url="${EXISTING_COMMENT_URL}"
          current_round="${CURRENT_ROUND}"
          current_trace="${CURRENT_TRACE}"
          should_post='false'
          reason='post-work-unavailable'

          if [ "${result}" = 'success' ] && [ "${success}" = 'true' ] && [ "${changed}" = 'true' ]; then
            should_post='true'
            reason=''
          elif [ "${result}" = 'success' ] && [ "${success}" = 'true' ]; then
            reason='branch-not-advanced'
          elif [ "${result}" = 'skipped' ] && [ "${dry_run}" = 'true' ]; then
            reason='dry-run'
          elif [ -z "${result}" ] && [ "${dry_run}" = 'true' ]; then
            reason='dry-run'
          elif [ -z "${result}" ]; then
            reason='post-work-not-run'
          else
            reason="${result}"
          fi

          if [ "${should_post}" = 'true' ]; then
            if [ -n "${existing_round}" ] && [ -n "${current_round}" ] && [ "${existing_round}" = "${current_round}" ]; then
              same_trace='false'
              if [ -n "${existing_trace}" ] && [ -n "${current_trace}" ] && [ "${existing_trace}" = "${current_trace}" ]; then
                same_trace='true'
              fi
              if [ "${same_trace}" = 'true' ] || [ "${existing_reaction}" = 'true' ]; then
                should_post='false'
                reason='existing-instruction'
              fi
            fi
          fi

          {
            echo "should_post=${should_post}"
            echo "skip_reason=${reason}"
          } >>"$GITHUB_OUTPUT"

          {
            echo "SHOULD_POST=${should_post}"
            echo "SKIP_REASON=${reason}"
            echo "EXISTING_COMMENT_ID=${existing_comment_id}"
            echo "EXISTING_COMMENT_URL=${existing_comment_url}"
          } >>"$GITHUB_ENV"
        env:
          POST_WORK_RESULT: ${{ needs.keepalive-post-work.result || '' }}
          POST_WORK_SUCCESS: ${{ needs.keepalive-post-work.outputs.success || '' }}
          POST_WORK_CHANGED: ${{ needs.keepalive-post-work.outputs.changed || '' }}
          DRY_RUN: ${{ needs.resolve-params.outputs.dry_run || '' }}
          EXISTING_ROUND: ${{ needs.keepalive-prep.outputs.existing_instruction_round || '' }}
          EXISTING_TRACE: ${{ needs.keepalive-prep.outputs.existing_instruction_trace || '' }}
          EXISTING_REACTION: ${{ needs.keepalive-prep.outputs.existing_instruction_reaction || 'false' }}
          EXISTING_COMMENT_ID: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_id || '' }}
          EXISTING_COMMENT_URL: ${{ needs.keepalive-prep.outputs.existing_instruction_comment_url || '' }}
          CURRENT_ROUND: ${{ needs.keepalive-prep.outputs.round || '' }}
          CURRENT_TRACE: ${{ needs.keepalive-prep.outputs.trace || '' }}

      - name: Checkout orchestrator scripts
        if: steps.gate.outputs.should_post == 'true'
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Select keepalive author token
        id: author_token
        if: steps.gate.outputs.should_post == 'true'
        shell: bash
        env:
          PREFLIGHT_TOKEN: ${{ needs.token-preflight.outputs.token_source || '' }}
        run: |
          set -euo pipefail
          token="${PREFLIGHT_TOKEN}"
          if [ "${token}" = 'ACTIONS_BOT_PAT' ]; then
            echo "token=ACTIONS_BOT_PAT" >>"$GITHUB_OUTPUT"
            echo "author=stranske" >>"$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "${token}" = 'SERVICE_BOT_PAT' ]; then
            echo "token=SERVICE_BOT_PAT" >>"$GITHUB_OUTPUT"
            echo "author=stranske-automation-bot" >>"$GITHUB_OUTPUT"
            exit 0
          fi

          echo "token=" >>"$GITHUB_OUTPUT"
          echo "author=" >>"$GITHUB_OUTPUT"
          echo "::error::Token preflight did not select a valid keepalive author token." >&2
          exit 1

      - name: Enforce keepalive author invariant
        id: author_invariant
        if: steps.gate.outputs.should_post == 'true'
        env:
          SELECTED_TOKEN: ${{ steps.author_token.outputs.token || '' }}
        run: |
          set -euo pipefail
          if [ "${SELECTED_TOKEN}" != 'ACTIONS_BOT_PAT' ]; then
            echo "::error::Keepalive instruction must post as stranske (ACTIONS_BOT_PAT). Selected token: ${SELECTED_TOKEN:-none}." >&2
            exit 1
          fi

      - name: Post keepalive instruction (as stranske if possible)
        id: post_instruction_primary
        if: steps.gate.outputs.should_post == 'true' && steps.author_token.outputs.token == 'ACTIONS_BOT_PAT'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_BODY: ${{ needs.keepalive-prep.outputs.body }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(issueNumber) || issueNumber <= 0) {
              core.setFailed('Keepalive instruction missing pull request number.');
              return;
            }
            const body = process.env.COMMENT_BODY || '';
            if (!body.trim()) {
              core.setFailed('Keepalive instruction body is empty.');
              return;
            }
            const { data: comment } = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body,
            });
            core.setOutput('comment-id', comment?.id ? String(comment.id) : '');
            core.setOutput('comment-url', comment?.html_url || '');
            core.setOutput('comment-author', comment?.user?.login || '');

      - name: Post keepalive instruction (fallback)
        id: post_instruction_fallback
        if: steps.gate.outputs.should_post == 'true' && steps.author_token.outputs.token == 'SERVICE_BOT_PAT'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_BODY: ${{ needs.keepalive-prep.outputs.body }}
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(issueNumber) || issueNumber <= 0) {
              core.setFailed('Keepalive instruction missing pull request number.');
              return;
            }
            const body = process.env.COMMENT_BODY || '';
            if (!body.trim()) {
              core.setFailed('Keepalive instruction body is empty.');
              return;
            }
            const { data: comment } = await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body,
            });
            core.setOutput('comment-id', comment?.id ? String(comment.id) : '');
            core.setOutput('comment-url', comment?.html_url || '');
            core.setOutput('comment-author', comment?.user?.login || '');

      - name: Capture instruction comment metadata
        id: capture_comment
        if: steps.gate.outputs.should_post == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.author_token.outputs.token }}" = 'ACTIONS_BOT_PAT' ]; then
            comment_id="${{ steps.post_instruction_primary.outputs.comment-id || '' }}"
            comment_url="${{ steps.post_instruction_primary.outputs.comment-url || '' }}"
            comment_author="${{ steps.post_instruction_primary.outputs.comment-author || '' }}"
          else
            comment_id="${{ steps.post_instruction_fallback.outputs.comment-id || '' }}"
            comment_url="${{ steps.post_instruction_fallback.outputs.comment-url || '' }}"
            comment_author="${{ steps.post_instruction_fallback.outputs.comment-author || '' }}"
          fi

          if [ -z "${comment_id}" ]; then
            echo "::error::Keepalive instruction comment was not created." >&2
            exit 1
          fi

          expected_author='${{ steps.author_token.outputs.author || '' }}'
          if [ -n "${comment_author}" ] && [ -n "${expected_author}" ] && [ "${comment_author}" != "${expected_author}" ]; then
            echo "::error::Keepalive instruction posted as ${comment_author}, expected ${expected_author}." >&2
            exit 1
          fi

          resolved_author="${comment_author:-${expected_author}}"

          echo "comment_id=${comment_id}" >>"$GITHUB_OUTPUT"
          echo "comment_url=${comment_url}" >>"$GITHUB_OUTPUT"
          echo "COMMENT_ID=${comment_id}" >>"$GITHUB_ENV"
          echo "COMMENT_URL=${comment_url}" >>"$GITHUB_ENV"
          echo "author=${resolved_author}" >>"$GITHUB_OUTPUT"
          echo "AUTHOR=${resolved_author}" >>"$GITHUB_ENV"

      - name: Ack keepalive instruction
        id: ack
        if: steps.gate.outputs.should_post == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id }}
          EXPECTED_AUTHOR: ${{ steps.author_token.outputs.author || '' }}
        with:
          github-token: ${{ steps.author_token.outputs.token == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const commentId = Number(process.env.COMMENT_ID || 0);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setFailed('Keepalive instruction comment id missing.');
              return;
            }

            const { owner, repo } = context.repo;
            const expectedAuthor = normalise(process.env.EXPECTED_AUTHOR).toLowerCase();

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'hooray',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add 🥳 reaction to keepalive comment ${commentId}: ${message}`);
            }

            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'eyes',
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add 👀 reaction to keepalive comment ${commentId}: ${message}`);
            }

            let commentTimestamp = 0;
            let commentAuthor = '';
            try {
              const { data: commentDetails } = await github.rest.issues.getComment({ owner, repo, comment_id: commentId });
              commentTimestamp = Date.parse(commentDetails?.updated_at || commentDetails?.created_at || '') || 0;
              commentAuthor = normalise(commentDetails?.user?.login);
              if (expectedAuthor && commentAuthor && commentAuthor.toLowerCase() !== expectedAuthor) {
                core.setFailed(
                  `Keepalive instruction author mismatch: expected ${expectedAuthor}, received ${commentAuthor}.`
                );
                return;
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to fetch keepalive comment ${commentId} metadata: ${message}`);
            }

            if (commentAuthor) {
              core.setOutput('author_login', commentAuthor);
            }

            const deadline = Date.now() + 180_000;
            const pollDelay = 5_000;
            const runPollInterval = 15_000;
            let lastRunCheck = 0;
            let acknowledged = false;
            let ackSource = '';

            const checkWorkflowRuns = async () => {
              try {
                const response = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: 'agents-pr-meta.yml',
                  event: 'issue_comment',
                  per_page: 20,
                });
                const runs = Array.isArray(response?.data?.workflow_runs) ? response.data.workflow_runs : [];
                for (const run of runs) {
                  const startedAt = Date.parse(run?.run_started_at || run?.created_at || '') || 0;
                  if (commentTimestamp && startedAt && startedAt + 5000 < commentTimestamp) {
                    continue;
                  }
                  const status = String(run?.status || '').toLowerCase();
                  const conclusion = String(run?.conclusion || '').toLowerCase();
                  if (status === 'completed' && conclusion === 'success') {
                    return true;
                  }
                }
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to inspect PR-meta workflow runs for comment ${commentId}: ${message}`);
              }
              return false;
            };

            while (Date.now() < deadline) {
              const reactions = await github.paginate(github.rest.reactions.listForIssueComment, {
                owner,
                repo,
                comment_id: commentId,
                per_page: 100,
              });
              if (reactions.some((reaction) => (reaction?.content || '').toLowerCase() === 'rocket')) {
                acknowledged = true;
                ackSource = 'reaction';
                break;
              }

              if (Date.now() - lastRunCheck >= runPollInterval) {
                lastRunCheck = Date.now();
                const runAck = await checkWorkflowRuns();
                if (runAck) {
                  acknowledged = true;
                  ackSource = 'pr-meta';
                  break;
                }
              }

              await new Promise((resolve) => setTimeout(resolve, pollDelay));
            }

            core.setOutput('acknowledged', acknowledged ? 'true' : 'false');
            core.setOutput('ack_source', ackSource);

      - name: Emit fallback dispatch
        if: steps.gate.outputs.should_post == 'true' && steps.ack.outputs.acknowledged != 'true' && needs.keepalive-prep.outputs.actions_available == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id }}
          COMMENT_URL: ${{ steps.capture_comment.outputs.comment_url }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.dispatcher_force_issue }}
          DISPATCH_MODE: ${{ needs.keepalive-prep.outputs.dispatch_mode }}
          AGENT_ALIAS: ${{ needs.keepalive-prep.outputs.agent }}
          INSTRUCTION_BODY: ${{ needs.keepalive-prep.outputs.instruction_body }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const commentId = Number(process.env.COMMENT_ID || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0 || !Number.isFinite(commentId) || commentId <= 0) {
              core.warning('Skipping fallback dispatch: pull request or comment id unavailable.');
              return;
            }

            const { owner, repo } = context.repo;
            let base = '';
            let head = '';
            let issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            let forked = false;

            try {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              base = pr?.base?.ref || '';
              head = pr?.head?.ref || '';
              const headRepo = pr?.head?.repo?.full_name || '';
              const forkFlag = pr?.head?.repo?.fork;
              const repoFullName = `${owner}/${repo}`.toLowerCase();
              if (forkFlag || (headRepo && headRepo.toLowerCase() !== repoFullName)) {
                forked = true;
              }
              if (!issueNumber) {
                const match = (pr?.head?.ref || '').match(/issue-+(\d+)/i);
                if (match) {
                  issueNumber = Number.parseInt(match[1], 10);
                }
              }
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to resolve pull request context for fallback dispatch: ${message}`);
            }

            if (!base || !head) {
              core.warning('Fallback dispatch skipped: unable to determine base/head.');
              return;
            }

            if (forked) {
              core.info('Fallback dispatch skipped: pull request originates from a fork.');
              return;
            }

            const instructionBody = (process.env.INSTRUCTION_BODY || '').trim();
            if (!instructionBody) {
              core.info('Fallback dispatch skipped: instruction segment unavailable.');
              return;
            }

            // GitHub repository_dispatch limits client_payload to 10 top-level properties.
            // Nest auxiliary data under `meta` to stay within the limit.
            const payload = {
              issue: issueNumber || prNumber,
              base,
              head,
              agent: (process.env.AGENT_ALIAS || '').trim() || 'codex',
              instruction_body: instructionBody,
              dispatch_mode: process.env.DISPATCH_MODE || '',
              meta: {
                comment_id: commentId,
                comment_url: process.env.COMMENT_URL || '',
                round: process.env.ROUND || '',
                trace: process.env.TRACE || '',
              },
              quiet: true,
              reply: 'none',
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: payload,
            });

      - name: Post fallback comment
        if: steps.gate.outputs.should_post == 'true' && steps.ack.outputs.acknowledged != 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.keepalive-prep.outputs.pr_number }}
          ROUND: ${{ needs.keepalive-prep.outputs.round }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace }}
        with:
          github-token: ${{ steps.author_token.outputs.token == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Unable to post fallback comment: missing PR number.');
              return;
            }

            const { owner, repo } = context.repo;
            const body = `**Keepalive ${process.env.ROUND || '?' }** \`${process.env.TRACE || ''}\` fallback: PR-meta ack not observed in TTL – emitted connector dispatch.`;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });

      - name: Record instruction observability line
        if: always()
        shell: bash
        env:
          SHOULD_POST: ${{ steps.gate.outputs.should_post || 'false' }}
          SKIP_REASON: ${{ steps.gate.outputs.skip_reason || '' }}
          TRACE: ${{ needs.keepalive-prep.outputs.trace || '' }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
          AUTHOR: ${{ steps.ack.outputs.author_login || steps.capture_comment.outputs.author || steps.author_token.outputs.author || '' }}
          COMMENT_ID: ${{ steps.capture_comment.outputs.comment_id || '' }}
          ACKNOWLEDGED: ${{ steps.ack.outputs.acknowledged || '' }}
          AUTHOR_TOKEN: ${{ steps.author_token.outputs.token || '' }}
          AUTHOR_INVARIANT_OUTCOME: ${{ steps.author_invariant.outcome || '' }}
          POST_PRIMARY_OUTCOME: ${{ steps.post_instruction_primary.outcome || '' }}
          POST_FALLBACK_OUTCOME: ${{ steps.post_instruction_fallback.outcome || '' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi
          head="${BASELINE_HEAD:-}"
          if [ -n "${head}" ]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi

          should_post="${SHOULD_POST:-false}"
          comment_id="${COMMENT_ID:-}"
          author="${AUTHOR:-}"
          if [ -z "${author}" ]; then
            author='none'
          fi
          ack_state="${ACKNOWLEDGED:-}"
          if [ "${ack_state}" = 'true' ]; then
            ack='ok'
          else
            ack='fail'
          fi

          if [ "${should_post}" != 'true' ]; then
            reason="${SKIP_REASON:-unknown}"
            printf 'INSTRUCTION: ok=false author=%s comment=none ack=fail head=%s trace=%s reason=%s\n' \
              "${author}" "${head}" "${trace}" "${reason:-unknown}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ "${AUTHOR_INVARIANT_OUTCOME}" = 'failure' ]; then
            token="${AUTHOR_TOKEN:-}"
            if [ -z "${token}" ]; then
              token='github.token'
            fi
            printf 'INSTRUCTION: ok=false author=none comment=none ack=fail head=%s trace=%s reason=wrong-author token=%s\n' \
              "${head}" "${trace}" "${token}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          if [ -n "${comment_id}" ]; then
            printf 'INSTRUCTION: ok=true author=%s comment=%s ack=%s head=%s trace=%s\n' \
              "${author}" "${comment_id}" "${ack}" "${head}" "${trace}" >>"$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          reason='unknown'
          if [ "${POST_PRIMARY_OUTCOME}" = 'failure' ] || [ "${POST_FALLBACK_OUTCOME}" = 'failure' ]; then
            reason='post-error'
          fi
          printf 'INSTRUCTION: ok=false author=%s comment=none ack=fail head=%s trace=%s reason=%s\n' \
            "${author}" "${head}" "${trace}" "${reason}" >>"$GITHUB_STEP_SUMMARY"

  belt-dispatch-summary:
    name: Summarise Codex dispatch outcomes
    needs:
      - belt-dispatch
      - belt-worker
      - belt-check-existing-pr
      - keepalive-guard
      - keepalive-cap
      - keepalive-prep
      - keepalive-instruction
      - keepalive-post-work
      - dry-run-branch-sync
      - resolve-params
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Emit worker observability line
        if: always()
        shell: bash
        env:
          PROCEED: ${{ needs.keepalive-guard.outputs.proceed || 'false' }}
          CAP_OK: ${{ needs.keepalive-cap.outputs.ok || 'false' }}
          SHOULD_POST: ${{ needs.keepalive-instruction.outputs.should_post || 'false' }}
          COMMENT_ID: ${{ needs.keepalive-instruction.outputs.comment_id || '' }}
          TRACE: ${{ needs.keepalive-instruction.outputs.trace || needs.keepalive-prep.outputs.trace || needs.resolve-params.outputs.keepalive_trace || '' }}
          PR_NUMBER: ${{ needs.keepalive-instruction.outputs.pr_number || needs.keepalive-prep.outputs.pr_number || needs.resolve-params.outputs.keepalive_pr || '' }}
          BASELINE_HEAD: ${{ needs.keepalive-prep.outputs.baseline_head || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          INSTRUCTION_RESULT: ${{ needs.keepalive-instruction.result || '' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi

          pr_value='?'
          if [ -n "${PR_NUMBER}" ]; then
            pr_value="${PR_NUMBER}"
          fi
          pr_label="#${pr_value}"

          head="${BASELINE_HEAD:-}"
          if [ -n "${head}" ]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi

          instr="${COMMENT_ID:-}"
          if [ -z "${instr}" ]; then
            instr='none'
          fi

          action='skip'
          reason='blocked'
          worker_result="${WORKER_RESULT:-}"

          if [ "${PROCEED}" != 'true' ]; then
            reason='blocked'
          elif [ "${CAP_OK}" != 'true' ]; then
            reason='cap-reached'
          elif [ "${worker_result}" = 'success' ]; then
            action='execute'
            reason='new-instruction'
          elif [ "${worker_result}" = 'failure' ]; then
            action='execute'
            reason='blocked'
          elif [ "${SHOULD_POST}" = 'true' ]; then
            reason='blocked'
          else
            reason='no-new-instruction-and-head-unchanged'
          fi

          printf 'WORKER: action=%s reason=%s pr=%s head=%s instr=%s trace=%s\n' \
            "${action}" "${reason}" "${pr_label}" "${head}" "${instr}" "${trace}" >>"$GITHUB_STEP_SUMMARY"

      - name: Emit sync observability line
        if: always()
        shell: bash
        env:
          TRACE: ${{ needs.keepalive-instruction.outputs.trace || needs.keepalive-prep.outputs.trace || needs.resolve-params.outputs.keepalive_trace || '' }}
          ACTION: ${{ needs.keepalive-post-work.outputs.action || '' }}
          CHANGED: ${{ needs.keepalive-post-work.outputs.changed || 'false' }}
          LINK: ${{ needs.keepalive-post-work.outputs.link || '-' }}
        run: |
          set -euo pipefail
          trace="${TRACE:-}"
          if [ -z "${trace}" ]; then
            trace='n/a'
          fi
          action="${ACTION:-}"
          if [ -z "${action}" ]; then
            action='skip'
          fi
          head_changed='false'
          if [ "${CHANGED}" = 'true' ]; then
            head_changed='true'
          fi
            link="${LINK:-}"
            if [ -z "${link}" ]; then
              link='-'
            fi
            printf 'SYNC: action=%s head_changed=%s link=%s trace=%s\n' "${action}" "${head_changed}" "${link}" "${trace}" >>"$GITHUB_STEP_SUMMARY"

      - name: Record existing PR guard outcome
        if: needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker guard
          * Status: skipped: PR exists.
          * Existing PR: [#${{ needs.belt-check-existing-pr.outputs.pr_number }}](${{ needs.belt-check-existing-pr.outputs.pr_url }})
          EOF

      - name: Highlight worker failure
        if: needs.belt-worker.result == 'failure'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker
          * Result: failure – see Agents 72 logs for details.
          EOF

      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Append dispatch summary
        uses: actions/github-script@v7
        env:
          DISPATCH_RESULT: ${{ needs.belt-dispatch.result || '' }}
          DISPATCH_ISSUE: ${{ needs.belt-dispatch.outputs.issue || '' }}
          DISPATCH_REASON: ${{ needs.belt-dispatch.outputs.reason || '' }}
          WORKER_RESULT: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true') && 'skipped: PR exists.' || needs.belt-worker.result || '' }}"
          WORKER_ALLOWED: ${{ needs.belt-worker.outputs.allowed || '' }}
          WORKER_PR_NUMBER: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true') && needs.belt-check-existing-pr.outputs.pr_number || needs.belt-worker.outputs.pr_number || needs.keepalive-instruction.outputs.pr_number || needs.resolve-params.outputs.keepalive_pr || '' }}"
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
          KEEPALIVE_ACTION: ${{ needs.belt-worker.outputs.keepalive_action || '' }}
          KEEPALIVE_REASON: ${{ needs.belt-worker.outputs.keepalive_reason || '' }}
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { appendDispatchSummary } = require('./.github/scripts/agents_dispatch_summary.js');
            await appendDispatchSummary({ core, context, env: process.env });

      - name: Record keepalive worker outcome
        if: |
          needs.keepalive-guard.outputs.proceed != 'false' &&
          needs.keepalive-instruction.outputs.trace != ''
        uses: actions/github-script@v7
        env:
          KEEPALIVE_TRACE: ${{ needs.keepalive-instruction.outputs.trace }}
          KEEPALIVE_ROUND: ${{ needs.keepalive-instruction.outputs.round || needs.resolve-params.outputs.keepalive_round }}
          KEEPALIVE_PR: ${{ needs.keepalive-instruction.outputs.pr_number || needs.belt-worker.outputs.pr_number || needs.resolve-params.outputs.keepalive_pr || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
          KEEPALIVE_ACTION: ${{ needs.belt-worker.outputs.keepalive_action || '' }}
          KEEPALIVE_REASON: ${{ needs.belt-worker.outputs.keepalive_reason || '' }}
          KEEPALIVE_HEAD_SHA: ${{ needs.belt-worker.outputs.keepalive_head_sha || '' }}
          KEEPALIVE_LAST_INSTRUCTION_ID: ${{ needs.belt-worker.outputs.keepalive_last_instruction_id || '' }}
          KEEPALIVE_LAST_INSTRUCTION_HEAD: ${{ needs.belt-worker.outputs.keepalive_last_instruction_head_sha || '' }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const trace = normalise(process.env.KEEPALIVE_TRACE);
            const round = normalise(process.env.KEEPALIVE_ROUND);
            const workerResult = normalise(process.env.WORKER_RESULT) || 'unknown';
            const branch = normalise(process.env.WORKER_BRANCH);
            const dryRun = normalise(process.env.WORKER_DRY_RUN).toLowerCase() === 'true';
            const prCandidate = normalise(process.env.KEEPALIVE_PR);
            const prNumber = Number(prCandidate);
            const { owner, repo } = context.repo;

            let headSha = '';
            if (branch) {
              try {
                const { data } = await github.rest.repos.getBranch({ owner, repo, branch });
                headSha = data?.commit?.sha || '';
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Unable to determine head SHA for ${branch}: ${message}`);
              }
            }

            if (!headSha) {
              headSha = normalise(process.env.KEEPALIVE_HEAD_SHA);
            }

            const keepaliveAction = normalise(process.env.KEEPALIVE_ACTION) || 'unknown';
            const keepaliveReason = normalise(process.env.KEEPALIVE_REASON);
            const lastInstructionId = normalise(process.env.KEEPALIVE_LAST_INSTRUCTION_ID);
            const lastInstructionHead = normalise(process.env.KEEPALIVE_LAST_INSTRUCTION_HEAD);

            const summary = core.summary;
            summary
              .addHeading('Keepalive worker outcome')
              .addTable([
                [
                  { data: 'Round', header: true },
                  { data: 'Trace', header: true },
                  { data: 'Result', header: true },
                  { data: 'Head SHA', header: true }
                ],
                [
                  round || '—',
                  trace || '—',
                  workerResult,
                  headSha || '(unavailable)'
                ]
              ])
              .addTable([
                [
                  { data: 'Action', header: true },
                  { data: 'Reason', header: true },
                  { data: 'Last Instruction', header: true },
                  { data: 'Last Head SHA', header: true }
                ],
                [
                  keepaliveAction,
                  keepaliveReason || '—',
                  lastInstructionId || '—',
                  lastInstructionHead ? lastInstructionHead.slice(0, 12) : '—'
                ]
              ])
              .write();

            if (!trace) {
              core.info('No keepalive trace detected; skipping worker outcome comment.');
              return;
            }

            if (!prNumber || !Number.isFinite(prNumber)) {
              core.info('No PR number resolved for keepalive worker outcome; skipping comment.');
              return;
            }

            const loweredResult = workerResult.toLowerCase();
            const shouldComment = headSha || loweredResult !== 'skipped';

            if (!shouldComment) {
              core.info('Keepalive worker skipped; no outcome comment posted.');
              return;
            }

            const shortSha = headSha ? headSha.slice(0, 12) : 'unknown';
            let details = `worker ${workerResult}`;
            if (dryRun) {
              details += ' (dry run)';
            }
            if (headSha) {
              details += ` – head ${shortSha}`;
            }

            const body = `**Keepalive ${round || '?'}** \`${trace}\` worker: ${details}.`;

            try {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body,
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to post keepalive worker outcome for PR #${prNumber}: ${message}`);
            }

      - name: Record branch-sync validation outcome
        if: needs.dry-run-branch-sync.result == 'success'
        env:
          RUN_URL: ${{ needs.dry-run-branch-sync.outputs.run_url }}
          CONCLUSION: ${{ needs.dry-run-branch-sync.outputs.run_conclusion }}
          HEAD_UPDATED: ${{ needs.dry-run-branch-sync.outputs.head_updated }}
          NEW_HEAD: ${{ needs.dry-run-branch-sync.outputs.new_head }}
          PR_URL: ${{ needs.dry-run-branch-sync.outputs.pr_url }}
        run: |
          head_change='unchanged'
          if [ "${HEAD_UPDATED}" = 'true' ] && [ -n "${NEW_HEAD}" ]; then
            head_change="advanced to ${NEW_HEAD:0:12}"
          fi

          sync_link='(not available)'
          if [ -n "${RUN_URL}" ]; then
            sync_link="[run](${RUN_URL})"
          fi

          pr_link='(n/a)'
          if [ -n "${PR_URL}" ]; then
            pr_link="[link](${PR_URL})"
          fi

          cat <<EOF >>"$GITHUB_STEP_SUMMARY"
          ## Branch-sync validation (dry-run)
          * Result: ${CONCLUSION:-unknown}
          * Workflow: ${sync_link}
          * PR: ${pr_link}
          * Head change: ${head_change}
          EOF
  belt-scan-ready-prs:
    name: Scan Codex promotion queue
    needs:
      - resolve-params
      - keepalive-guard
    runs-on: ubuntu-latest
    outputs:
      items: ${{ steps.scan.outputs.items || '[]' }}
    env:
      MAX_PROMOTIONS: ${{ needs.resolve-params.outputs.conveyor_max_merges }}
    steps:
      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Identify ready Codex PRs
        id: scan
        uses: actions/github-script@v7
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { identifyReadyCodexPRs } = require('./.github/scripts/agents_belt_scan.js');
            await identifyReadyCodexPRs({ github, context, core, env: process.env });

  belt-conveyor:
    name: Promote Codex PRs
    needs:
      - resolve-params
      - belt-scan-ready-prs
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.conveyor_max_merges != '0' &&
      needs.belt-scan-ready-prs.outputs.items != '' &&
      needs.belt-scan-ready-prs.outputs.items != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.belt-scan-ready-prs.outputs.items) }}
    uses: ./.github/workflows/agents-73-codex-belt-conveyor.yml
    with:
      issue: ${{ matrix.pr.issue || 0 }}
      branch: ${{ matrix.pr.branch }}
      pr_number: ${{ matrix.pr.pr }}
      head_sha: ${{ matrix.pr.head_sha }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      ACTIONS_BOT_PAT: ${{ secrets.ACTIONS_BOT_PAT }}

  automerge-agent-prs:
    name: Auto-merge labelled agent PRs
    needs:
      - resolve-params
      - belt-conveyor
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false' && needs.resolve-params.outputs.dry_run != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Merge Codex PRs tagged for automerge
        id: automerge
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || '' }}
          AUTOMERGE_LABEL: automerge
          AUTOMATION_USERS: ${{ needs.resolve-params.outputs.codex_user }}
        with:
          github-token: ${{ secrets.OWNER_PR_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const label = (process.env.AUTOMERGE_LABEL || 'automerge').trim();
            const summary = core.summary;
            const { owner, repo } = context.repo;

            let defaultBranch = (process.env.DEFAULT_BRANCH || '').trim();
            if (!defaultBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.default_branch || 'main';
            }

            const automationUsersRaw = process.env.AUTOMATION_USERS || '';
            const automationUsers = automationUsersRaw
              .split(',')
              .map((login) => login.trim())
              .filter(Boolean);
            if (!automationUsers.length) {
              automationUsers.push('stranske-automation-bot');
            }

            async function loadPullRequest(pull_number) {
              let attempt = 0;
              while (true) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (!pr) {
                  return null;
                }
                const state = (pr.mergeable_state || '').toLowerCase();
                if (state && state !== 'unknown') {
                  return pr;
                }
                attempt += 1;
                if (attempt >= 2) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', labels: label, per_page: 100 }
            );

            const rows = [];
            const merged = [];

            summary.addHeading('Agent auto-merge scan');
            if (!issues.length) {
              summary.addRaw(`No open pull requests carry the "${label}" label.`).addEOL();
              await summary.write();
              core.setOutput('merged', JSON.stringify(merged));
              return;
            }

            for (const issue of issues) {
              if (!issue || !issue.pull_request) {
                continue;
              }

              const prNumber = Number(issue.number);
              let note = '';
              let status = 'skipped';

              try {
                const pr = await loadPullRequest(prNumber);
                if (!pr) {
                  note = 'Unable to load pull request data.';
                } else {
                  const author = pr.user && pr.user.login ? pr.user.login : '';
                  if (!automationUsers.includes(author)) {
                    note = `Author @${author || 'unknown'} is not an automation account.`;
                  } else if ((pr.base && pr.base.ref) !== defaultBranch) {
                    note = `Base branch ${pr.base && pr.base.ref ? pr.base.ref : '(unknown)'} does not match ${defaultBranch}.`;
                  } else if (pr.draft) {
                    note = 'Draft pull requests are not eligible for auto-merge.';
                  } else {
                    const mergeableState = (pr.mergeable_state || '').toLowerCase();
                    if (['blocked', 'dirty', 'draft'].includes(mergeableState)) {
                      if (mergeableState === 'blocked') {
                        note = 'Branch protection blocks the merge (mergeable_state=blocked).';
                      } else if (mergeableState === 'dirty') {
                        note = 'Merge conflicts detected (mergeable_state=dirty).';
                      } else {
                        note = `Mergeable state ${mergeableState} prevents auto-merge.`;
                      }
                    } else {
                      const headSha = pr.head && pr.head.sha ? pr.head.sha : '';
                      if (!headSha) {
                        note = 'Missing head SHA for pull request.';
                      } else {
                        const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                          owner,
                          repo,
                          ref: headSha
                        });
                        if (!combined || combined.state !== 'success') {
                          note = 'Required status checks have not all succeeded.';
                        } else {
                          let checksOk = true;
                          let failingCheck = '';
                          try {
                            const { data: checks } = await github.rest.checks.listForRef({
                              owner,
                              repo,
                              ref: headSha,
                              per_page: 100
                            });
                            const checkRuns = Array.isArray(checks.check_runs) ? checks.check_runs : [];
                            for (const run of checkRuns) {
                              const conclusion = (run.conclusion || '').toLowerCase();
                              const statusName = run.name || run.id || 'unknown check';
                              if (!conclusion && run.status !== 'completed') {
                                checksOk = false;
                                failingCheck = `${statusName} pending`;
                                break;
                              }
                              if (conclusion && !['success', 'neutral', 'skipped'].includes(conclusion)) {
                                checksOk = false;
                                failingCheck = `${statusName} concluded ${conclusion}`;
                                break;
                              }
                            }
                          } catch (error) {
                            checksOk = false;
                            failingCheck = `Unable to list check runs: ${error.message || error}`;
                          }

                          if (!checksOk) {
                            note = failingCheck || 'Checks have not completed successfully.';
                          } else {
                            const mergeParams = {
                              owner,
                              repo,
                              pull_number: prNumber,
                              merge_method: 'squash'
                            };
                            try {
                              const response = await github.rest.pulls.merge(mergeParams);
                              if (response && response.data && response.data.merged) {
                                status = 'merged';
                                note = `Merged via ${response.data.merge_method || mergeParams.merge_method}.`;
                                merged.push(prNumber);
                              } else {
                                status = 'error';
                                note = 'Merge API returned an unexpected response.';
                              }
                            } catch (error) {
                              status = 'error';

                              const message = error instanceof Error ? error.message : String(error);
                              const response = error && typeof error === 'object' ? error.response : undefined;
                              const responseData = response && typeof response === 'object' ? response.data : undefined;

                              let details = '';
                              if (responseData && typeof responseData.message === 'string' && responseData.message.trim()) {
                                details = responseData.message.trim();
                              }

                              if (
                                responseData &&
                                Array.isArray(responseData.errors) &&
                                responseData.errors.length
                              ) {
                                const extras = responseData.errors
                                  .map((entry) => {
                                    if (!entry) {
                                      return '';
                                    }
                                    if (typeof entry === 'string') {
                                      return entry;
                                    }
                                    if (typeof entry.message === 'string' && entry.message.trim()) {
                                      return entry.message.trim();
                                    }
                                    try {
                                      return JSON.stringify(entry);
                                    } catch (jsonError) {
                                      return '';
                                    }
                                  })
                                  .filter(Boolean)
                                  .join('; ');
                                if (extras) {
                                  details = details ? `${details} (${extras})` : extras;
                                }
                              }

                              if (!details) {
                                details = message;
                              }

                              const lowered = (details || '').toLowerCase();
                              if (lowered.includes('protected') || lowered.includes('required status check')) {
                                note = `Blocked by branch protection: ${details}`;
                              } else {
                                note = `Merge failed: ${details}`;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } catch (error) {
                status = 'error';
                const message = error instanceof Error ? error.message : String(error);
                note = `Failed to evaluate PR #${prNumber}: ${message}`;
              }

              if (status === 'skipped' && !note) {
                note = 'Auto-merge conditions not satisfied.';
              }

              rows.push([
                `#${prNumber}`,
                status,
                note
              ]);
            }

            if (rows.length) {
              summary.addTable([
                [
                  { data: 'PR', header: true },
                  { data: 'Result', header: true },
                  { data: 'Details', header: true }
                ],
                ...rows
              ]);
            }

            if (!merged.length) {
              summary
                .addRaw('No pull requests were merged automatically during this scan.')
                .addEOL();
            }

            await summary.write();
            core.setOutput('merged', JSON.stringify(merged));
