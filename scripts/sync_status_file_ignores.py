#!/usr/bin/env python3
"""Sync shared status file .gitignore patterns to consumer repos.

This script ensures all consumer repos have the canonical .gitignore entries
for auto-generated status files that cause merge conflicts.

Usage:
    # Check what would be added (dry-run)
    python scripts/sync_status_file_ignores.py --check

    # Generate patch for a specific repo's .gitignore
    python scripts/sync_status_file_ignores.py --repo stranske/Trend_Model_Project

    # Output the canonical block to stdout
    python scripts/sync_status_file_ignores.py --print-block

The canonical patterns are defined in:
    templates/consumer-repo/.gitignore

These patterns prevent merge conflicts from:
- autofix_report_enriched.json (updated every PR)
- codex-prompt.md / codex-output.md (rebuilt every keepalive)
- keepalive-metrics.ndjson (append-only metrics)
- And other workflow-generated files
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path

# Canonical status file patterns that should be ignored
# These are the minimum patterns needed to prevent merge conflicts
CANONICAL_PATTERNS: list[str] = [
    # Agent working files (HIGH conflict risk)
    "codex-prompt.md",
    "codex-output.md",
    "codex-prompt-*.md",
    "codex-output-*.md",
    "verifier-context.md",
    # Autofix status files (HIGH conflict risk)
    "autofix_report_enriched.json",
    ".cosmetic-repair-summary.json",
    "ci/autofix/history.json",
    "ci/autofix/diagnostics.json",
    # Metrics/history files (MEDIUM conflict risk)
    "keepalive-metrics.ndjson",
    "coverage-trend-history.ndjson",
    "metrics-history.ndjson",
    "residual-trend-history.ndjson",
    # Build artifacts
    ".autofix-venv/",
]

GITIGNORE_BLOCK_HEADER = """# =============================================================================
# Workflows Consumer Repo - Shared Status Files
# =============================================================================
# Auto-generated by workflows; causes merge conflicts if committed.
# Sync from: stranske/Workflows templates/consumer-repo/.gitignore
# =============================================================================
"""


def load_template_gitignore() -> str:
    """Load the canonical .gitignore template."""
    template_path = Path(__file__).parent.parent / "templates/consumer-repo/.gitignore"
    if template_path.exists():
        return template_path.read_text()
    # Fallback to generating from patterns
    return generate_minimal_block()


def generate_minimal_block() -> str:
    """Generate minimal .gitignore block from canonical patterns."""
    lines = [GITIGNORE_BLOCK_HEADER.strip()]
    for pattern in CANONICAL_PATTERNS:
        lines.append(pattern)
    return "\n".join(lines) + "\n"


def check_gitignore_content(content: str) -> dict[str, bool]:
    """Check which canonical patterns are present in .gitignore content."""
    # Normalize: remove comments and empty lines for comparison
    lines = set()
    for line in content.splitlines():
        stripped = line.strip()
        if stripped and not stripped.startswith("#"):
            # Handle negation patterns (lines starting with !)
            if stripped.startswith("!"):
                continue  # Skip negation patterns
            lines.add(stripped)

    return {pattern: pattern in lines for pattern in CANONICAL_PATTERNS}


def get_missing_patterns(content: str) -> list[str]:
    """Get list of canonical patterns missing from .gitignore."""
    status = check_gitignore_content(content)
    return [pattern for pattern, present in status.items() if not present]


def generate_append_block(missing: list[str]) -> str:
    """Generate a .gitignore block for missing patterns only."""
    if not missing:
        return ""

    lines = [
        "",
        "# --- Workflows Shared Status Files (auto-synced) ---",
        "# Prevents merge conflicts from workflow-generated files",
    ]
    lines.extend(missing)
    return "\n".join(lines) + "\n"


def print_check_report(content: str, repo_name: str = "local") -> int:
    """Print a report of pattern coverage and return exit code."""
    status = check_gitignore_content(content)
    missing = [p for p, present in status.items() if not present]
    present = [p for p, present in status.items() if present]

    print(f"\n=== Status File .gitignore Check: {repo_name} ===\n")

    if present:
        print(f"✓ Present ({len(present)}/{len(CANONICAL_PATTERNS)}):")
        for p in present:
            print(f"  ✓ {p}")

    if missing:
        print(f"\n✗ Missing ({len(missing)}/{len(CANONICAL_PATTERNS)}):")
        for p in missing:
            print(f"  ✗ {p}")
        print("\nTo fix, add these patterns to .gitignore:")
        print(generate_append_block(missing))
        return 1

    print("\n✓ All canonical patterns present!")
    return 0


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Sync shared status file .gitignore patterns",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check local .gitignore for missing patterns",
    )
    parser.add_argument(
        "--repo",
        help="GitHub repo (owner/name) to check via API",
    )
    parser.add_argument(
        "--print-block",
        action="store_true",
        help="Print the canonical .gitignore block",
    )
    parser.add_argument(
        "--print-patterns",
        action="store_true",
        help="Print just the pattern list (one per line)",
    )
    parser.add_argument(
        "--gitignore-path",
        type=Path,
        help="Path to local .gitignore to check",
    )

    args = parser.parse_args()

    if args.print_block:
        print(load_template_gitignore())
        return 0

    if args.print_patterns:
        for pattern in CANONICAL_PATTERNS:
            print(pattern)
        return 0

    if args.gitignore_path:
        if not args.gitignore_path.exists():
            print(f"Error: {args.gitignore_path} not found", file=sys.stderr)
            return 1
        content = args.gitignore_path.read_text()
        return print_check_report(content, str(args.gitignore_path))

    if args.check:
        # Check local repo's .gitignore
        local_gitignore = Path(".gitignore")
        if not local_gitignore.exists():
            print("No .gitignore found in current directory", file=sys.stderr)
            return 1
        content = local_gitignore.read_text()
        return print_check_report(content, "local")

    if args.repo:
        # Check remote repo via GitHub API
        import subprocess

        result = subprocess.run(
            [
                "gh",
                "api",
                f"repos/{args.repo}/contents/.gitignore",
                "--jq",
                ".content",
            ],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            print(f"Error fetching .gitignore from {args.repo}", file=sys.stderr)
            print(result.stderr, file=sys.stderr)
            return 1

        import base64

        content = base64.b64decode(result.stdout.strip()).decode()
        return print_check_report(content, args.repo)

    # Default: print help
    parser.print_help()
    return 0


if __name__ == "__main__":
    sys.exit(main())
